# JS — 原型对象

![image-20201112185136797](/images/JS_img/image-20201112185136797.png)

> ==原型prototype==

我们所创建的每一个函数，解析器都会向函数中添加一个属性prototype
这个属性对应着一个对象，这个对象就是我们所谓的原型对象  

- 如果函数作为普通函数调用，prototype没作用
- 当函数以构造函数的形式调用时，它所创建的对象都含有一个隐含的属性来指向该构造函数的原型对象，我们可以通过\__proto__来访问该属性

原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问这个原型对象。

当我们访问一个对象的属性或者方法时，它会现在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。

## 原型对象的原型

![image-20201112192126069](/images/JS_img/image-20201112192126069.png)

因为原型对象也是一个对象，所以他也有原型!

![image-20201112192545629](/images/JS_img/image-20201112192545629.png)

原型对象中的方法是可以修改的

## prototype与\__proto__的区别

### 概念区分

其实说\__proto__ 并不准确，确切的说是对象的[[prototype]]属性，只不过在主流的浏览器中，都用\__proto__ 来代表[[prototype]]属性，因为[[prototype]]只是一个标准，而针对这个标准，不同的浏览器有不同的实现方式。在ES5中用Object.getPrototypeOf函数获得一个对象的[[prototype]]。ES6中，使用Object.setPrototypeOf可以直接修改一个对象的[[prototype]]。为了方便，我下面的文章用\__proto__ 来代表对象的[[prototype]]。

而prototype属性是只有函数才特有的属性，当你创建一个函数时，js会自动为这个函数加上prototype属性，值是一个空对象。所以，函数在js中是非常特殊的，是所谓的一等公民

### 明确要点

> 对象中

对象具有属性\__proto__ ，可称为**隐式原型**，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法

> 函数中

函数这个特殊的对象，除了和其他对象一样有上述_proto_属性之外，还有自己特有的属性——**原型属性（prototype）**，这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数

![img](/images/JS_img/v2-5e55da48225128b0281dcec72950f93a_1440w.jpg)

```js
var arr = new Array("23",989);   //创建一个数组（对象）
console.log(arr.__proto__ == Array.prototype);  // true
console.log(arr.prototype);  // undefined
```
